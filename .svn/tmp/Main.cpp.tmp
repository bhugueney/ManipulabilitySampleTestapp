

#include "MatrixDefs.h"
#include "Pi.h"

#include "ManipManager.h"
#include "PostureManager.h"
#include "draw/DrawManager.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#ifdef WIN32
#include <windows.h>
#endif

#include <iostream>
#include <vector>


using namespace matrices;
using namespace Eigen;
using namespace std;
using namespace manip_core;

// main object

ManipManager manager;
DrawManager drawManager(manager);
static float xyz[3] = {-10.0,1,3.0};
static float hpr[3] = {0.0,0.0,0.0};

void BuildWorld()
{
	// FORWARD OBSTACLES
	Vector3 p1(-11,2,0.4f);
	Vector3 p2(-5.5,2,0.4f);
	Vector3 p3(-5.5,-1,0.4f);
	Vector3 p4(-11,-1,0.4f);

	manager.AddObstacle(p1,p2,p3,p4);

	Vector3 p11(-5.2, 2, 0.f);
	Vector3 p21( -1, -1, 0.f);
	manager.GenerateStairChess(p11, p21, 0.4, 1.2,  3, 2);

	Vector3 p13(-0.8, 2, 1.7f);
	Vector3 p23( 3, -1, 1.7f);
	manager.GenerateXInclinedPlank(p13, p23);

	Vector3 p131(3.1, 3, 2.0f);
	Vector3 p231( 6, 1, 1.5f);
	manager.GenerateXInclinedPlank(p131, p231);

	Vector3 p132(3.1, 0, 1.5f);
	Vector3 p232( 6, -2, 2.0f);
	manager.GenerateXInclinedPlank(p132, p232);


	Vector3 p136(6.2, 1, 1.5f);
	Vector3 p236( 18, 0.7, 1.5f);
	manager.GenerateXInclinedPlank(p136, p236);
	
	manager.Initialize();
}

<<<<<<< .working

void Rotate(RobotI* robot, const matrices::Matrix3& rotation)
{
	matrices::Matrix4 transform;
	double transf[16];
	robot->ToWorldCoordinates(transf);
	matrices::array16ToMatrix4(transf, transform);
	transform.block<3,3>(0,0) = transform.block<3,3>(0,0) * rotation;
	matrices::matrixTo16Array(transf, transform);
	robot->SetTransform(transf);
}

void XboxControl(RobotI * robot)
{
	controller.Update();
	float xL, yL;
	float xR, yR;
	bool transformed = false;
	const float slowDownFactor = 0.01f;
	controller.GetLeftStickMovingVector(xL, yL);
	controller.GetRightStickMovingVector(xR, yR);
	if( xL != 0 || yL != 0)
	{
		double trans[3] = {((double)xL * slowDownFactor*2), 0., ((double)yL * slowDownFactor)};
		robot->Translate(trans);
		oldDir_ = Vector3(xL, 0, yL);
		oldDir_.normalize();
		transformed = true;
	}
	if( yR != 0)
	{
		transformed = true;
		Rotate(pRobot, matrices::Roty3(-yR * slowDownFactor*2));

	}
	if( xR != 0)
	{
		//transformed = true;
		//Rotate(pRobot, matrices::Rotx3(xR * slowDownFactor*3));

	}
	if(transformed)
	{
		matrices::Matrix4 transform;
		double transf[16];
		robot->ToWorldCoordinates(transf);
		matrices::array16ToMatrix4(transf, transform);
		xyz[0] = transform(0,3);// - 5;
		xyz[1] = transform(1,3)+ 5;
		xyz[2] = transform(2,3);
		//postureManager->NextPosture(pRobot,matrices::matrix4TimesVect3(transform, oldDir_));
		postureManager->NextPosture(pRobot, oldDir_);
		dsSetViewpoint (xyz,hpr);
	}
	if(controller.AllPressed((int)xbox::Buttons::Y))
	{
		Matrix4 robotBasis(MatrixX::Identity(4,4));
		robotBasis(0,3) = -8;
		robotBasis(1,3) = 1.;
		robotBasis(2,3) = 2.;
		pRobot->Release();
		pRobot = manager.CreateRobot(enums::robot::Human, robotBasis);
		delete dr;
		dr = new DrawRobot(pRobot);
	}
}

=======
>>>>>>> .merge-right.r97
static void simLoop (int pause)
{
	drawManager.Draw();
}

void start()
{
    dsSetViewpoint (xyz,hpr);
}

void command(int cmd)   /**  key control function; */
{
	Vector3 trX(0.01, 0, 0);
	Vector3 trY(0,0.01,  0);
	switch (cmd)
	{	
		case '+' :
			drawManager.NextPosture();
		break;
		case '-' :
			drawManager.PreviousPosture();
		break;
	}
}


int main(int argc, char *argv[])
{
	//init robot
	Matrix4 robotBasis(MatrixX::Identity(4,4));
	robotBasis(0,3) = -10;

	BuildWorld();

<<<<<<< .working
	pRobot = manager.CreateRobot(enums::robot::Human, robotBasis);
	dr = new DrawRobot(pRobot);
=======
	const RobotI* pRobot = manager.CreateRobot(enums::robot::Quadruped, robotBasis);
	
	PostureManager* postureManager = manager.GetPostureManager();
	postureManager->Compute(pRobot, 100);
>>>>>>> .merge-right.r97
	/* TEST */
	//sg->GenerateSamples(*pRobot, 243);

	Vector3 robotBasis2(0,0,0);

	/* trajectory */
	robotBasis2(0) = -9.9;
	postureManager->AddCheckPoint( 1.f, robotBasis2);

	robotBasis2(2) = 0.;
	robotBasis2(0) = -8;
	postureManager->AddCheckPoint( 2, robotBasis2);

	robotBasis2(0) = -7;
	robotBasis2(2) = 0.0;
	postureManager->AddCheckPoint( 3, robotBasis2);

	robotBasis2(0) = -5;
	//robotBasis2(2) = 0.2;
	postureManager->AddCheckPoint( 4, robotBasis2);

	robotBasis2(0) = -2;
	robotBasis2(2) = 0.4;
	postureManager->AddCheckPoint( 5, robotBasis2);

	robotBasis2(0) = -1;
	robotBasis2(2) = 0.8;
	postureManager->AddCheckPoint( 6, robotBasis2);

	robotBasis2(0) = 1.3;
	robotBasis2(2) = 1.3;
	postureManager->AddCheckPoint( 7, robotBasis2);


	robotBasis2(0) = 6;
	robotBasis2(2) = 1.0;
	postureManager->AddCheckPoint( 8, robotBasis2);

	robotBasis2(0) = 12;
	robotBasis2(2) = 1.2;
	postureManager->AddCheckPoint( 9, robotBasis2);

	robotBasis2(0) = 18;
	robotBasis2(2) = 1.7;
	postureManager->AddCheckPoint( 10, robotBasis2);

/* trajectory */
	postureManager->Compute(pRobot,100);
/*TEST */

	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
	fn.command = &command;
    fn.stop    = 0;
    fn.path_to_textures = "../textures";
    dsSimulationLoop (argc,argv,800,600,&fn);

    return 0;
}
