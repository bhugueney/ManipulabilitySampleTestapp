
#include "IKSolver.h"
#include "kinematic/Tree.h"
#include "sampling/Sample.h"
#include "kinematic/Jacobian.h"
#include "PartialDerivativeConstraint.h"
#include "IkConstraintHandler.h"

#include "API/TreeI.h"

#include <vector>
#include <iostream>

using namespace matrices;
using namespace Eigen;
using namespace std;
using namespace manip_core;

struct IKPImpl
{
	IKPImpl()
	{
		//TODO
	}

	~IKPImpl()
	{
		// NOTHING
	}
};

IKSolver::IKSolver(const float espilon, const float treshold)
: epsilon_(espilon)
, treshold_(treshold)
, pImpl_(new IKPImpl)
{
	// NOTHING
}

IKSolver::~IKSolver()
{
	// NOTHING
}

void IKSolver::Release()
{
	delete this;
}


//bool IKSolver::QuickStepClamping(Tree& tree, const matrices::Vector3& target) const
//{
//	Jacobian jacobian(tree); 
//	Vector3 force = target - tree.GetEffectorPosition(tree.GetNumEffector()-1) ; //TODO we only have one effector  so weird huh ?
//	
//	if(force.norm() < treshold_) // reached treshold
//	{
//		return true;
//	}
//	VectorX velocities;
//	MatrixX J = jacobian.GetJacobianCopy(); int colsJ = J.cols(); int rowsJ = J.rows();
//	
//	Vector3 dX = (force / force.norm()) * treshold_ * 0.1; // TODO real trajectory please ?
//	
//	//null space projection
//	MatrixX p0 = MatrixX::Identity(colsJ, colsJ);
//	MatrixX nullSpace = p0;
//
//	// init all joints to free.
//	bool freeJoint[20];// no more than 20 joint ok :)
//	for(int i = 0; i < colsJ; ++i)
//	{
//		freeJoint[i]=true;
//	}
//		
//	bool clamp = false;
//	//entering clamping loop
//	do
//	{
//		velocities = jacobian.GetJacobianInverse() * dX;
//		// now to the "fun" part
//		clamp = false;
//		for(int i =0; i < colsJ; ++ i)
//		{
//			if(freeJoint[i])
//			{
//				NUMBER overload = tree.GetJoint(i+1)->AddToTheta(velocities(i));
//				if (overload != 0.f) // clamping happened
//				{
//					freeJoint[i] = false;
//					clamp = true;
//					dX -= J.col(i) * overload;
//					J.col(i) = VectorX::Zero(rowsJ);
//					p0(i,i) = 0;
//				}
//			}
//		}
//		if(clamp)
//			jacobian.SetJacobian(J);
//	} while(clamp);
//	return false;
//}


//REF: Boulic : An inverse kinematics architecture enforcing an arbitrary number of strict priority levels
bool IKSolver::StepClamping(Tree& tree, const matrices::Vector3& target, const Vector3& direction, const IkConstraintHandler* constraints) const
{
	assert(constraints);
	Jacobian jacobian(tree); 
	VectorX postureVariation(VectorX::Zero(jacobian.GetJacobian().cols()));
	PartialDerivatives(tree, direction, postureVariation, constraints);

	Vector3 force = target - tree.GetEffectorPosition(tree.GetNumEffector()-1) ; //TODO we only have one effector  so weird huh ?
	
	if(force.norm() < treshold_) // reached treshold
	{
		//return true;
	}
	VectorX velocities;
	MatrixX J = jacobian.GetJacobianCopy(); int colsJ = J.cols(); int rowsJ = J.rows();
	
	Vector3 dX = (force / force.norm()) * treshold_ * 0.2; // TODO real trajectory please ?
	
	//null space projection
	MatrixX p0 = MatrixX::Identity(colsJ, colsJ);
	MatrixX nullSpace = p0;

	// init all joints to free.
	bool freeJoint[20];// no more than 20 joint ok :)
	for(int i = 0; i < colsJ; ++i)
	{
		freeJoint[i]=true;
	}
		
	bool clamp = false;
	//entering clamping loop
	do
	{
		jacobian.GetNullspace(p0, nullSpace); // Pn(j) = P0(j) - Jtr * J

		velocities = jacobian.GetJacobianInverse() * dX + nullSpace * postureVariation;
		// now to the "fun" part
		clamp = false;
		for(int i =0; i < colsJ; ++ i)
		{
			if(freeJoint[i])
			{
				NUMBER overload = tree.GetJoint(i+1)->AddToTheta(velocities(i));
				if(overload != 0.f) // clamping happened
				{
					freeJoint[i] = false;
					clamp = true;
					dX -= J.col(i) * overload;
					J.col(i) = VectorX::Zero(rowsJ);
					p0(i,i) = 0;
				}
			}
		}
		if(clamp)
			jacobian.SetJacobian(J);
	} while(clamp);
	return false;
}

//bool IKSolver::QuickStepClamping(TreeI* pTree, const double* target) const
//{
//	const matrices::Vector3 unitX(1,0,0);
//	Tree* tree = (static_cast<Tree*>(pTree));
//	matrices::Vector3 targ;
//	matrices::arrayToVect3(target, targ);
//	return StepClamping(*tree, targ, unitX, &(pImpl_->emptyConstraints_));
//	//return StepClamping(*tree, targ, unitX);
//}

bool IKSolver::StepClamping(TreeI* pTree, const double* target, const double* direction, const manip_core::IkConstraintHandlerI* constraints) const
{
	Tree* tree = (static_cast<Tree*>(pTree));
	matrices::Vector3 targ, tdir;
	matrices::arrayToVect3(target, targ);
	matrices::arrayToVect3(direction, tdir);
	const IkConstraintHandler* cons = (static_cast<const IkConstraintHandler*>(constraints));
	return StepClamping(*tree, targ, tdir, cons);
	//return StepClamping(*tree, targ, unitX);
}


void IKSolver::PartialDerivative(Tree& tree, const Vector3& direction, VectorX& velocities, const IkConstraintHandler* constraints, const int joint) const
{
	Sample save(tree); // saving previous tree
	tree.GetJoint(joint)->AddToTheta(-epsilon_);
	tree.Compute();
	Jacobian jacobMinus(tree);
	save.LoadIntoTree(tree); // loading it

	tree.GetJoint(joint)->AddToTheta(epsilon_);
	tree.Compute();
	Jacobian jacobPlus(tree);
	save.LoadIntoTree(tree); // loading it
	
	const IkConstraintHandler::T_Constraint& cons = constraints->GetConstraints();
	for(IkConstraintHandler::T_ConstraintCIT it = cons.begin(); it!= cons.end(); ++it)
	{
		velocities(joint-1) += ((*it).second)->Evaluate(jacobMinus, jacobPlus, epsilon_, direction);
	}
}

void IKSolver::PartialDerivatives(Tree& tree, const Vector3& direction, VectorX& velocities, const IkConstraintHandler* constraints) const
{
	for(int i =1; i<= velocities.rows() ;++i)
	{
		PartialDerivative(tree, direction, velocities, constraints, i);
	}
}
