

CreatePostures( robot, trajectory)

	List<timeStep, Robot> postures
	
	Vector currentDir, oldPosition, oldDirection
	Robot previousPosture
	Matrix4x4 oldtranformation, transformation
	
	transformation  <- robot.transformation
	previousPosture <- robot
	oldDirection    <- robot.currentDirection
	oldPosition     <- robot.position
	int trajectoryIndex     <- -1
	timestep <- 0
	
	while(trajectoryIndex < trajectory.size())
	{
		trajectoryIndex <- trajectoryIndex + 1		
		currentDir     <- Trajectory[trajectoryIndex].direction
		
		oldtransformation <- transformation
		tranformation     <- ComputeTransformation(oldDirection, currentDir, Trajectory[trajectoryIndex].position)
		
		bool Success, Robot newPosture
		Success, newPosture <- CreatePosture(previousPosture, Trajectory[trajectoryIndex], tranformation)
		
		if(Success)
		{
			oldPosition  <- Trajectory[trajectoryIndex].position
			oldDirection <- currentDir
			timestep <- Trajectory[trajectoryIndex].timestep
			postures.Add(timestep, newPosture)
		}
		// let's reduce gap between wayPoints by adding one between trajectories
		else
		{
			if(Trajectory.AddWayPoint(previousPosture, trajectoryIndex))
			{
				trajectoryIndex <- trajectoryIndex - 1
			}
			else
			{
				//we're trapped. Do the best we can without moving
				tranformation <- oldtransformation
				timestep <- timestep + 0.001f
				newPosture <- CreateStillPosture(previousPosture, timestep, tranformation);
				postures.Add(timestep, newPosture)
			}
		}
	}
	
	for(; it != timepos.end(); ++it)
		{
			Robot* newPosture = CreatePosture(*previousPosture, (*it).first, tranformation, changed);
			if(newPosture) // only one contact was changed ? ok!
			{
				if(!changed) // new Posture is different
				{
					pImpl_->postures_.pop_back();
				}
				pImpl_->postures_.push_back(std::make_pair((*it).first, newPosture));
				previousPosture = newPosture;
			}
			else // let's reduce gap between wayPoints by adding one between trajectories
			{
				oldDirection = pImpl_->currentDir_;
				oldPosition = pImpl_->postures_.back().second->ToWorldCoordinates().block(0,3,3,1);
				tranformation = pImpl_->postures_.back().second->ToWorldCoordinates();
				if(!trajectory.AddWayPoint(--it)) // it placed on the new waypoint
				{
					//we're trapped. Do the best we can without moving
					pImpl_->currentDirWeight_ = 0;
					//oldPosition = tranformation.block(0,3,3,1);
					newPosture = CreateStillPosture(*previousPosture, pImpl_->postures_.back().first + 0.01f, tranformation);
					pImpl_->postures_.push_back(std::make_pair((*it).first, newPosture));
					previousPosture = newPosture;
					++it; // skip next posture
					it2 = it;
					++it2;
				}
				else
				{
					it--; // because it ll be increased in loop
					it2 = it;
					++it2;
				}
			}
		}
	
	
	
	currentDir <- Trajectory[trajectoryIndex].position - oldPosition
	currentDir.Normalize()
	tranformation  <- ComputeTransformation(oldDirection, currentDir, oldPosition)
	previousPosture = CreatePosture(previousPosture, (*it).first, tranformation, changed)