
#include "DrawRobot.h"
#include "DrawTree.h"
//#include "DrawSupportPolygon.h"

#include "API/RobotI.h"
#include "API/TreeI.h"

#include "MatrixDefs.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#include <vector>

using namespace std;
using namespace matrices;
using namespace manip_core;

struct PImpl
{
	PImpl(const RobotI* robot)
		:robot_(robot)
		,drawSupport_(false)
	{
		//NOTHING
	}

	~PImpl()
	{
		//NOTHING
	}

	const RobotI* robot_;

	typedef vector<DrawTree> T_Tree;
	typedef T_Tree::iterator T_TreeIT;
	typedef T_Tree::const_iterator T_TreeCIT;
	T_Tree drawTrees_;
	bool drawSupport_;
};



//TODO listener in case of adding new trees
DrawRobot::DrawRobot(const RobotI* robot)
	: pImpl_(new PImpl(robot))
{
	const TreeI* trunk = robot->GetTorsoI();

	if(trunk)
	{
		pImpl_->drawTrees_.push_back(DrawTree(trunk, 0.04f, 0.25f));
	}
	int nTrees = robot->GetNumTrees();
	double vect[3];
	for(int i=0; i < nTrees; ++i)
	{
		const TreeI* pTree = robot->GetTreeI(i);
		robot->GetTreeAttach(i, vect);
		pImpl_->drawTrees_.push_back(DrawTree(pTree, vect));
	}
	/*robot.Accept(*this);
	const Tree* trunk = robot.GetTorso();
	if(trunk)
	{
		pImpl_->drawTrees_.push_back(DrawTree(*trunk));
	}*/
}

DrawRobot::~DrawRobot()
{
	// TODO
}

void DrawRobot::ToggleSupportPolygon(bool onoff)
{
	pImpl_->drawSupport_ = onoff;
}

const manip_core::RobotI* DrawRobot::GetRobot()
{
	return pImpl_->robot_;
}

void DrawRobot::DrawEllipsoid(int treeId) const
{
	double robotCoord[16];
	Matrix4 currentTransform;
	Vector3 pos, v1, v2, v3;
	double from[3];
	double u1[3];
	double u2[3];
	double u3[3];
	TreeI* tree = pImpl_->robot_->GetTreeI(treeId);
	if(tree)
	{
	pImpl_->robot_->ToWorldCoordinates(robotCoord);
	matrices::array16ToMatrix4(robotCoord, currentTransform);
	tree->EndEffectorPosition(from);
	matrices::arrayToVect3(from, pos);
	pos = matrices::matrix4TimesVect3(currentTransform, pos);
	matrices::vect3ToArray(from, pos);
	tree->GetEllipsoidAxes(u1, u2, u3);

	matrices::arrayToVect3(u1, v1);
	matrices::arrayToVect3(u2, v2); 
	matrices::arrayToVect3(u3, v3);
	//glColor3f(0.3f, 0.4f, 0.7f);
	dsSetColor(	0.3f, 0.4f, 0.7f);
	//dsSetTexture(0);
	//dsSetColorAlpha(0,0,1,0.3);
	//glPushMatrix();
	//// translating to point center
	//glTranslatef(pos.x(), pos.y(), pos.z());
	////glRotate(angle, axis.x, axis.y, axis.z);
	//// Scaling to ellipsoid values
	//glScalef(v1.norm(), v2.norm(), v3.norm());
	//gluSphere(quad, 1, 100, 100);
	//glPopMatrix();
	v1 = pos + v1; matrices::vect3ToArray(u1, v1);
	v2 = pos + v2; matrices::vect3ToArray(u2, v2);
	v3 = pos + v3; matrices::vect3ToArray(u3, v3);
	dsDrawLineD(from, u1);
	dsDrawLineD(from, u2);
	dsDrawLineD(from, u3);
	}
}

void DrawRobot::Draw(bool transparency) const
{
	dsSetTexture(1);
	double currentTransform[16];
	pImpl_->robot_->ToWorldCoordinates(currentTransform);
	Matrix4 transform;
	matrices::array16ToMatrix4(currentTransform, transform);
	int i = 0;
	for(PImpl::T_TreeCIT it = pImpl_->drawTrees_.begin(); it!= pImpl_->drawTrees_.end(); ++it, ++i)
	{
		it->Draw(transform, transparency);
		//DrawEllipsoid(i);
	}
	dsSetTexture(0);

	//if(pImpl_->drawSupport_)
	//{
	//	Vector3 com = matrices::matrix4TimesVect3( pImpl_->robot_->ToWorldCoordinates(), pImpl_->robot_->ComputeCom());
	////Vector3 com = pRobot->ComputeCom();
	//	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	//	float t[3];
	//	t[0] = (float)(com(0));
	//	t[1] = (float)(com(1));
	//	t[2] = (float)(com(2));
	//	dsDrawSphere(t, Identity, 0.1f);
	//	SupportPolygon sp(*pImpl_->robot_);
	//	DrawSupportPolygon dsp(*pImpl_->robot_, sp);
	//	dsp.Draw();
	//}
}

void DrawRobot::DrawNoTexture() const
{
	dsSetTexture(0);
	double currentTransform[16];
	pImpl_->robot_->ToWorldCoordinates(currentTransform);
	Matrix4 transform;
	matrices::array16ToMatrix4(currentTransform, transform);
	for(PImpl::T_TreeCIT it = pImpl_->drawTrees_.begin(); it!= pImpl_->drawTrees_.end(); ++it)
	{
		it->DrawNoTexture(transform);
	}
	dsSetTexture(0);

	//if(pImpl_->drawSupport_)
	//{
	//	Vector3 com = matrices::matrix4TimesVect3( pImpl_->robot_->ToWorldCoordinates(), pImpl_->robot_->ComputeCom());
	////Vector3 com = pRobot->ComputeCom();
	//	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	//	float t[3];
	//	t[0] = (float)(com(0));
	//	t[1] = (float)(com(1));
	//	t[2] = (float)(com(2));
	//	dsDrawSphere(t, Identity, 0.1f);
	//	SupportPolygon sp(*pImpl_->robot_);
	//	DrawSupportPolygon dsp(*pImpl_->robot_, sp);
	//	dsp.Draw();
	//}
}

//void DrawRobot::Visit(const Tree& tree, const Joint* anchor)
//{
//	pImpl_->drawTrees_.push_back(DrawTree(tree));
//}

