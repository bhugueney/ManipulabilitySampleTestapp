
#include "IKSolver.h"
#include "Tree.h"
#include "Sample.h"
#include "Jacobian.h"
#include "PartialDerivativeConstraint.h"

#include <vector>
#include <iostream>

using namespace matrices;
using namespace Eigen;
using namespace std;

struct IKPImpl
{
	IKPImpl()
	{
		//TODO
	}

	~IKPImpl()
	{
		for( T_ConstraintIT it = constraints_.begin(); it!= constraints_.end(); ++it)
		{
			delete(*it);
		}
	}
	
	typedef vector<PartialDerivativeConstraint*> T_Constraint;
	typedef T_Constraint::iterator T_ConstraintIT;
	typedef T_Constraint::const_iterator T_ConstraintCIT;
	T_Constraint constraints_;
};

IKSolver::IKSolver( const float espilon, const float treshold )
: epsilon_(espilon)
, treshold_(treshold)
, pImpl_( new IKPImpl )
{
	// NOTHING
}

IKSolver::~IKSolver()
{
	// NOTHING
}


void IKSolver::Register( PartialDerivativeConstraint* constraint)
{
	pImpl_->constraints_.push_back(constraint);
}

//REF: Boulic : An inverse kinematics architecture enforcing an arbitrary number of strict priority levels
bool IKSolver::StepClamping( Tree& tree, const matrices::Vector3& target, const Vector3& direction ) const
{
	Jacobian jacobian(tree); 
	VectorXd postureVariation(VectorXd::Zero(jacobian.GetJacobian().cols()));
	PartialDerivatives( tree, direction, postureVariation);

	Vector3 force = target - tree.GetEffectorPosition(tree.GetNumEffector()-1) ; //TODO we only have one effector  so weird huh ?
	
	if( force.norm() < treshold_) // reached treshold
	{
		return true;
	}
	VectorXd velocities;
	MatrixXd J = jacobian.GetJacobianCopy(); int colsJ = J.cols(); int rowsJ = J.rows();
	
	Vector3 dX = ( force / force.norm() ) * treshold_ * 2; // TODO real trajectory please ?
	
	//null space projection
	MatrixXd p0 = Eigen::MatrixXd::Identity(colsJ, colsJ);
	MatrixXd nullSpace = p0;

	// init all joints to free.
	bool freeJoint[20];// no more than 20 joint ok :)
	for( int i = 0; i < colsJ; ++i )
	{
		freeJoint[i]=true;
	}
		
	bool clamp = false;
	//entering clamping loop
	do
	{
		jacobian.GetNullspace( p0, nullSpace ); // Pn(j) = P0(j) - Jtr * J

		velocities = jacobian.GetJacobianInverse() * dX + nullSpace * postureVariation;
		// now to the "fun" part
		clamp = false;
		for( int i =0; i < colsJ; ++ i)
		{
			if( freeJoint[i] )
			{
				NUMBER overload = tree.GetJoint(i+1)->AddToTheta(velocities(i));
				if( overload > 0.f ) // clamping happened
				{
					freeJoint[i] = false;
					clamp = true;
					dX -= J.col(i) * overload;
					J.col(i) = VectorXd::Zero(rowsJ);
					p0(i,i) = 0;
				}
			}
		}
		if(clamp)
			jacobian.SetJacobian(J);
	} while(clamp);
	return false;
}

/*bool IKSolver::ComputeJointVelocityNoNullSpace( Tree& tree, const Vector3& target, VectorXd& velocities ) const
{
	// Pseudo inverse method : introduction to inverse kin. with jacob... R. Bus
	// TODO
	Vector3 force = tree.GetEffectorPosition(tree.GetNumEffector()-1) - target; //TODO we only have one effector  so weird huh ?
	if( force.norm() < treshold_) // reached treshold
	{
		return true;
	}
	Jacobian jacobian(tree); 
	MatrixXd J = jacobian.GetJacobianCopy(); int colsJ = J.cols(); int rowsJ = J.rows();
	velocities = (jacobian.GetJacobianInverse() * ( force / force.norm() * 0.1 )); // Jacobian inverse
	return false;
}

void IKSolver::UpdateTree( Tree& tree, const VectorXd& velocities ) const
{
	for( int i = 1; i <= velocities.rows(); ++i ) // starting at 1 %*ù$ù
	{
		tree.GetJoint(i)->AddToTheta(-velocities(i-1));
	}
}

void IKSolver::PartialAvoidSingularities( Tree& tree, const Vector3& target, Eigen::VectorXd& velocities ) const
{
	VectorXd nullSpaceVelocities(velocities.rows());
	for( int i =1; i<= velocities.rows() ;++i)
	{
		Sample save(tree); // saving previous tree

		// force manip
		//float previousForceMan = tree.ComputeForceManipulability(*tree.directionForce_);
		float previousManipulability = tree.ComputeManipulability();
		tree.GetJoint(i)->AddToTheta(epsilon_);
		tree.Compute();
		tree.ComputeJacobian();
		nullSpaceVelocities(i-1) = ( previousManipulability + tree.ComputeManipulability() ) / epsilon_;
		//nullSpaceVelocities(i-1) += ( previousForceMan + tree.ComputeForceManipulability(*tree.directionForce_) ) / epsilon_;
		save.LoadIntoTree(tree); // loading it
		//test to clamp velocities
	}
	velocities += (tree.Identitymin)*(nullSpaceVelocities*5);
}

bool IKSolver::StepForceManipulability( Tree& tree, const Vector3& target, const Vector3& direction ) const
{
	Jacobian jacobian(tree);
	VectorXd velocities(VectorXd::Zero(jacobian.GetJacobian().cols()));
	PartialForceManDerivatives(tree, direction, velocities);
	return StepClamping( tree, jacobian, target, velocities);
	//if( !ComputeJointVelocityNoNullSpace(tree, target, velocities) )
	//{
	//	PartialForceManDerivatives(tree, direction, velocities);
	//	//test to clamp velocities
	//	UpdateTree(tree, velocities);
	//	return false;
	//}
	//return true;
}

bool IKSolver::StepForceAndAvoidManipulability( Tree& tree, const Vector3& target, const Vector3& direction ) const
{
	VectorXd velocities;
	if( !ComputeJointVelocityNoNullSpace(tree, target, velocities) )
	{
		PartialAvoidSingularities(tree, target, velocities);
		//test to clamp velocities
		UpdateTree(tree, velocities);
		return false;
	}
	return true;
}

bool IKSolver::Step( Tree& tree, const Vector3& target ) const // Pseudo inverse method : introduction to inverse kin. with jacob... R. Buss
{
	VectorXd velocities;
	if( !ComputeJointVelocityNoNullSpace(tree, target, velocities) )
	{
		UpdateTree(tree, velocities);
		return false;
	}
	return true;
}*/


/*
void IKSolver::PartialForceManDerivative(Tree& tree, const Vector3& direction, VectorXd& velocities, const int joint) const
{
	float previousMan;
	Sample save(tree); // saving previous tree
	tree.GetJoint(joint)->AddToTheta(-epsilon_);
	tree.Compute();
	tree.ComputeJacobian();
	//velocities(joint-1) = ( previousMan + tree.ComputeForceManipulability(direction) ) / epsilon_;
	save.LoadIntoTree(tree); // loading it
	previousMan = tree.ComputeForceManipulability(direction);

	tree.GetJoint(joint)->AddToTheta(epsilon_);
	tree.Compute();
	tree.ComputeJacobian();
	velocities(joint-1) = ( previousMan - tree.ComputeForceManipulability(direction) ) / ( epsilon_ * 2 ) ;
	save.LoadIntoTree(tree); // loading it
}


void IKSolver::PartialForceManDerivatives(Tree& tree, const Vector3& direction, VectorXd& velocities) const
{
	for( int i =1; i<= velocities.rows() ;++i)
	{
		PartialForceManDerivative( tree, direction, velocities, i);
	}
	//velocities += (tree.Identitymin * nullSpaceVelocities);
	velocities *= 0.3;
}
*/

void IKSolver::PartialDerivative(Tree& tree, const Vector3& direction, VectorXd& velocities, const int joint) const
{
	Sample save(tree); // saving previous tree
	tree.GetJoint(joint)->AddToTheta(-epsilon_);
	tree.Compute();
	Jacobian jacobMinus(tree);
	save.LoadIntoTree(tree); // loading it

	tree.GetJoint(joint)->AddToTheta(epsilon_);
	tree.Compute();
	Jacobian jacobPlus(tree);
	save.LoadIntoTree(tree); // loading it
	
	for( IKPImpl::T_ConstraintIT it = pImpl_->constraints_.begin(); it!= pImpl_->constraints_.end(); ++it)
	{
		velocities(joint-1) += (*it)->Evaluate(jacobMinus, jacobPlus, epsilon_, direction);
	}
}

void IKSolver::PartialDerivatives(Tree& tree, const Vector3& direction, VectorXd& velocities) const
{
	for( int i =1; i<= velocities.rows() ;++i)
	{
		PartialDerivative( tree, direction, velocities, i);
	}
	//velocities += (tree.Identitymin * nullSpaceVelocities);
	//velocities *= 0.3;
}