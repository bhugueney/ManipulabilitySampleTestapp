
#include "ObstacleGenerator.h"
#include "world/Obstacle.h"
#include "world/World.h"

using namespace matrices;
using namespace Eigen;

ObstacleGenerator::ObstacleGenerator()
{
	// NOTHING	
}

ObstacleGenerator::~ObstacleGenerator()
{
	// NOTHING
}

void ObstacleGenerator::GenerateChess(World& world, const matrices::Vector3& upLeft, const matrices::Vector3& bottomRight, NUMBER height, const unsigned int depth) const
{
	// stop condition, depth = 0, flat rectangle
	if(0 == depth)
	{
		Vector3 nUL (upLeft.x(), upLeft.y(), height);
		Vector3 nBR (bottomRight.x(), bottomRight.y(), height);
		Vector3 upRight(bottomRight.x(), upLeft.y(), height);
		Vector3 downLeft(upLeft.x(), bottomRight.y(), height);
		world.AddObstacle(new Obstacle(nUL, upRight, nBR, downLeft));
	}
	else
	{
		Vector3 dx((bottomRight.x() - upLeft.x()) / 2., 0, 0);
		Vector3 dy(0, (upLeft.y() - bottomRight.y()) / 2., 0);
		//NUMBER dHeight = (1 == depth) ? 0.3 : 0.;
		unsigned int newDepth = depth - 1;
		GenerateChess(world, upLeft, upLeft + dx - dy, height, newDepth);
		if(depth != 1)
		{
			GenerateChess(world, upLeft + dx, bottomRight + dy, height, newDepth);
			GenerateChess(world, upLeft - dy, bottomRight - dx, height, newDepth);
		}
		GenerateChess(world, upLeft + dx - dy, bottomRight, height, newDepth);
	}
}


void ObstacleGenerator::GenerateXInclinedPlank(World& world, const matrices::Vector3& upLeft, const matrices::Vector3& bottomRight) const
{
		Vector3 upRight(bottomRight.x(), upLeft.y(), upLeft.z());
		Vector3 downLeft(upLeft.x(), bottomRight.y(), bottomRight.z());
		world.AddObstacle(new Obstacle(upLeft, upRight, bottomRight, downLeft));
}

void ObstacleGenerator::GenerateYInclinedPlank(World& world, const matrices::Vector3& upLeft, const matrices::Vector3& bottomRight) const
{
		Vector3 upRight(bottomRight.x(), upLeft.y(), bottomRight.z());
		Vector3 downLeft(upLeft.x(), bottomRight.y(), upLeft.z());
		world.AddObstacle(new Obstacle(upLeft, upRight, bottomRight, downLeft));
}

void ObstacleGenerator::GenerateStair(World& world, const matrices::Vector3& upLeft, const matrices::Vector3& bottomRight, NUMBER heightInit, NUMBER heightFinal, const unsigned int depth) const
{
	NUMBER xLength = bottomRight.x() - upLeft.x();
	NUMBER yLength = upLeft.y() - bottomRight.y();
	bool xIsLonger = xLength > yLength;
	NUMBER deltaHeight = (heightFinal - heightInit) / ((NUMBER) depth);
	NUMBER deltaCaseWidth = xIsLonger ? (xLength / ((NUMBER) depth)) : (yLength / ((NUMBER) depth));
	// stop condition, depth = 0, flat rectangle
	for(unsigned int i = 0; i < depth; ++i)
	{
		if(xIsLonger)
		{
			Vector3 uL(upLeft.x() + deltaCaseWidth * i, upLeft.y(), heightInit + i * deltaHeight);
			Vector3 bR(upLeft.x() + deltaCaseWidth * (i+1), bottomRight.y(), heightInit + i * deltaHeight);
			GenerateXInclinedPlank(world, uL, bR);
		}
		else
		{
			Vector3 uL(upLeft.x()     , bottomRight.y() + deltaCaseWidth * (i + 1), heightInit + i * deltaHeight);
			Vector3 bR(bottomRight.x(), bottomRight.y() + deltaCaseWidth * i      , heightInit + i * deltaHeight);
			GenerateXInclinedPlank(world, uL, bR);
		}
	}
}

void ObstacleGenerator::GenerateStairChess(World& world, const matrices::Vector3& upLeft, const matrices::Vector3& bottomRight, NUMBER heightInit, NUMBER heightFinal, const unsigned int depth, const unsigned int chessdepth) const
{
	NUMBER xLength = bottomRight.x() - upLeft.x();
	NUMBER yLength = upLeft.y() - bottomRight.y();
	bool xIsLonger = xLength > yLength;
	NUMBER deltaHeight = (heightFinal - heightInit) / ((NUMBER) depth);
	NUMBER deltaCaseWidth = xIsLonger ? (xLength / ((NUMBER) depth)) : (yLength / ((NUMBER) depth));
	// stop condition, depth = 0, flat rectangle
	for(unsigned int i = 0; i < depth; ++i)
	{
		if(xIsLonger)
		{
			Vector3 uL(upLeft.x() + deltaCaseWidth * i, upLeft.y(), 0);
			Vector3 bR(upLeft.x() + deltaCaseWidth * (i+1), bottomRight.y(), 0);
			GenerateChess(world, uL, bR, heightInit + i * deltaHeight, chessdepth);
		}
		else
		{
			Vector3 uL(upLeft.x()     , bottomRight.y() + deltaCaseWidth * (i + 1), 0);
			Vector3 bR(bottomRight.x(), bottomRight.y() + deltaCaseWidth * i      , 0);
			GenerateChess(world, uL, bR, heightInit + i * deltaHeight, chessdepth);
		}
	}
}
