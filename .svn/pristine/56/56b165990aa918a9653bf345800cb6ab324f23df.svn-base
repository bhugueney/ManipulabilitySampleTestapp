
#include "FilterDistanceObstacle.h"

#include "world/Obstacle.h"
#include "kinematic/Robot.h"
#include "kinematic/Tree.h"
#include "kinematic/Sample.h"

#include <math.h>

using namespace matrices;
using namespace Eigen;

struct FilterDPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW

	FilterDPImpl(NUMBER treshold, const Tree& tree, const Obstacle& obstacle, const Robot& robot, const Vector3& direction)
	: treshold_(treshold)
	, treePos_(tree.GetPosition())
	, direction_(direction)
	{
		//toObstacleCoordinates_ = robot.ToWorldCoordinates() * obstacle.BasisInv();
		toObstacleCoordinates_ = obstacle.BasisInv() * robot.ToWorldCoordinates();
		obsW_ = obstacle.GetW(); obsH_ = obstacle.GetH();
	}

	~FilterDPImpl()
	{
		// NOTHING
	}
	
	NUMBER treshold_;
	const Vector3& direction_;
	Matrix4 toObstacleCoordinates_;
	Vector3 treePos_;
	NUMBER obsW_, obsH_;

};

FilterDistanceObstacle::FilterDistanceObstacle(NUMBER treshold, const Tree& tree, const Obstacle& obstacle, const Robot& robot, const Vector3& direction)
	: Filter_ABC()
	, pImpl_(new FilterDPImpl(treshold, tree, obstacle, robot, direction))
{
	// NOTHING
}

FilterDistanceObstacle::~FilterDistanceObstacle()
{
	// NOTHING
}

bool FilterDistanceObstacle::ApplyFilter(const Sample& sample) const
{
	// check that sample position is inside obstacle radius and not too far from its plan
	if(sample.GetPosition()(0) <=0 ) // we want to move forward
	{
		return false;
	}
	Vector3 center = matrix4TimesVect3(pImpl_->toObstacleCoordinates_, sample.GetPosition() + pImpl_->treePos_);
	NUMBER xc, yc;
	xc = center(0); yc = center(1);
	return (abs(center(2)) <= pImpl_->treshold_) && (xc >= 0 && xc <= pImpl_->obsW_) && (yc >= 0 && yc <= pImpl_->obsH_);
}

