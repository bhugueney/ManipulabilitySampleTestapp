
#include "TreeFactory.h"
#include "RobotFactory.h"
#include "Robot.h"
#include "kinematic/Tree.h"
#include "kinematic/Enums.h"

#include <vector>

using namespace matrices;
using namespace manip_core::enums;
using namespace manip_core::enums::robot;

namespace factories
{
const Vector3 unitx(1, 0, 0);
const Vector3 unity(0, 1, 0);
const Vector3 unitz(0, 0, 1);
const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
const Vector3 zero(0,0,0);

struct RobotFactoryPimpl{
	RobotFactoryPimpl()
	{
		// NOTHING
	}
	
	~RobotFactoryPimpl()
	{
		// NOTHING
	}

	// TODO Joint that do not move

	Robot* CreateHuman(const Matrix4& robotBasis) const
	{
		Robot* res = new Robot(robotBasis, treeFact_.CreateTree( HumanTorso, Vector3(0.0, 0., 0), 4), manip_core::enums::robot::Human);
		Tree* rightLeg = treeFact_.CreateTree( Leg, Vector3(0.0, -0.2, 0.1), 0);
		Tree* leftLeg  = treeFact_.CreateTree( Leg, Vector3(0.0, 0.2 , 0.1), 1);
		Tree* rightArm = treeFact_.CreateTree( Arm, Vector3(0.0, -0.4, 1.3), 2);
		Tree* leftArm  = treeFact_.CreateTree( Arm, Vector3(0.0, 0.4, 1.3), 3);
		res->AddTree(rightLeg, matrices::Vector3(0,0,0), 0);
		res->AddTree(leftLeg, matrices::Vector3(0,0,0), 0);
		res->AddTree(rightArm, matrices::Vector3(0,0,1.2), 1);
		res->AddTree(leftArm, matrices::Vector3(0,0,1.2), 1);
		/*rightLeg->LockTarget(rightLeg->GetTarget());
		leftLeg->LockTarget(leftLeg->GetTarget());*/

		rightLeg->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightLeg->GetPosition() + Vector3( -0.3, 0, -1.4)));
		leftLeg ->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), leftLeg->GetPosition()  + Vector3( 0.3, 0, -1.4)));

		return res;
	}

	Robot* CreateQuadruped(const Matrix4& robotBasis) const
	{
		// TODO Remove order neccessity to create ids ...
		Robot* res = new Robot(robotBasis, treeFact_.CreateTree( QuadrupedTorso, Vector3(0.0, 0., 0.0), 4), manip_core::enums::robot::Quadruped);
		factories::TreeFactory factory;
		Tree* rightLeg = treeFact_.CreateTree( QuadrupedLegRight, Vector3(0.0, -0.25, -0.1), 0);
		Tree* leftLeg  = treeFact_.CreateTree( QuadrupedLegLeft, Vector3(0.0, 0.25 , -0.1), 1);
		Tree* leftArm  = treeFact_.CreateTree( QuadrupedLegLeft, Vector3(1.5, 0.25 , -0.1), 2);
		Tree* rightArm = treeFact_.CreateTree( QuadrupedLegRight, Vector3(1.5, -0.25, -0.1), 3);
		res->AddTree(rightLeg, matrices::Vector3(0,0,0), 0);
		res->AddTree(leftLeg, matrices::Vector3(0,0,0), 0);
		res->AddTree(leftArm, matrices::Vector3(1.5,0,0), 1);
		res->AddTree(rightArm, matrices::Vector3(1.5,0,0), 1);
		/*rightLeg->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightLeg->GetPosition() + Vector3(-0.3, 0, -1.3)));
		leftLeg ->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), leftLeg->GetPosition()  + Vector3( 0.5, 0, -1.3)));
		rightArm->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightArm->GetPosition() + Vector3( 0.3, 0, -1.3)));*/

		rightLeg->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightLeg->GetPosition() + Vector3( -0.3, 0, -1.4)));
		leftLeg ->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), leftLeg->GetPosition()  + Vector3( 0.3, 0, -1.4)));
		rightArm->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightArm->GetPosition() + Vector3( 0.4, 0, -1.4)));
		leftArm->LockTarget (matrix4TimesVect3(res->ToWorldCoordinates(), leftArm->GetPosition()  + Vector3( -0.4, 0, -1.4)));

		return res;
	}

	TreeFactory treeFact_;
};
}

using namespace factories;

RobotFactory::RobotFactory()
	: pImpl_(new RobotFactoryPimpl())
{
	// NOTHING
}


RobotFactory::~RobotFactory()
{
	// NOTHING
}

Robot* RobotFactory::CreateRobot(const eRobots robots, const Matrix4& robotBasis) const
{
	switch (robots)
		{
		case Human:
				{
					return pImpl_->CreateHuman(robotBasis);
				}
			case Quadruped:
				{
					return pImpl_->CreateQuadruped(robotBasis);
				}
			default:
				throw(std::exception("unknown robot type"));
		}
}


