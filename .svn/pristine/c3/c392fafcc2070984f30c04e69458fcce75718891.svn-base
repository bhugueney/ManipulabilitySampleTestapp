
#include "DrawTree.h"
#include "MatrixDefs.h"

#include "API/RobotI.h"
#include "API/TreeI.h"
#include "API/JointI.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

using namespace matrices;
using namespace manip_core;

namespace matrices
{
	const Vector3 unitz(0,0,1);
}

DrawTree::DrawTree(const TreeI* tree, const float width, const float effectorWidth)
	: tree_(tree)
	, hasAttach_(false)
	, width_(width)
	, effectorWidth_(effectorWidth)
{
	// NOTHING
}

DrawTree::DrawTree(const TreeI* tree, const double* attach, const float width, const float effectorWidth)
	: tree_(tree)
	, hasAttach_(true)
	, width_(width)
	, effectorWidth_(effectorWidth)
{
	const JointI* joint = this->tree_->GetRootJointI();
	double vect[3];
	joint->Offset(vect);
	matrices::arrayToVect3(vect, rootPos_);
	matrices::arrayToVect3(attach, attach_);
}


DrawTree::~DrawTree()
{
	// NOTHING
}

void DrawTree::Draw(const matrices::Matrix4& currentTransform) const
{
	matrices::Matrix4 m = currentTransform;
	dsSetColor(1.0,0.0,0.0);
	const JointI* joint = this->tree_->GetRootJointI();
	if(tree_->IsAnchored())
	{
		dsSetColor(0.0,1.0,0.0);
	}
	else
	{
		dsSetColor(1.0,0.0,0.0);
	}
	if(hasAttach_)
	{
		Vector3 vFrom(matrices::matrix4TimesVect3(currentTransform, attach_));
		Vector3 vTo(matrices::matrix4TimesVect3(currentTransform, rootPos_));
		float from[3];
		float to[3];
		float R[12];
		matrices::vect3ToArray(from, vFrom);
		matrices::vect3ToArray(to, vTo);
		dsDrawLine(from, to);

		Vector3 trans(vTo - vFrom);
		
		matrices::vect3ToArray(from, vFrom + trans / 2.);
		trans.normalize();
		Matrix3 transformCube;
		GetRotationMatrix(unitz, trans, transformCube);
		matrix3ToArray(R, transformCube);
		dsDrawCapsule(from, R, (float)((vTo - vFrom).norm() - 0.01f), width_);
	}
	while(joint)
	{
		DrawJoint(m, joint);
		joint = (joint->IsEffector() ? 0 : joint->GetSon());
	}
}


//void DrawTree::Draw(const matrices::Matrix4& currentTransform) const
//{
//	matrices::Matrix4 m = currentTransform;
//		
//	if(tree_->IsLocked())
//	{
//		dsSetColor(0.0,1.0,0.0);
//		// draw target
//		float ps[3];
//		float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
//		vect3ToArray(ps, tree_->GetTarget());
//		dsDrawSphere (ps, Identity, 0.05f);
//	}
//	else
//	{
//		dsSetColor(1.0,0.0,0.0);
//	}
//	Joint* joint = tree_->GetRoot();
//	while (joint)
//	{
//		DrawJoint(m, joint);
//		joint = (joint->IsEffector() ? 0 : tree_->GetSuccessor(joint));
//	}
//}

using namespace enums;

void DrawTree::DrawJoint(matrices::Matrix4& currentTransform, const JointI* joint) const
{
	//draw line between positions
	Vector3 vFrom(currentTransform.block<3,1>(0,3));
	float from[3];
	vect3ToArray(from, vFrom);
	double vect[3];
	joint->Offset(vect);
	Vector3 offset;
	matrices::arrayToVect3(vect,offset);
	Matrix4 jointTransform = Translate(offset); // translation of current joint
	switch(joint->GetRotation())
	{
		case rotation::X:
			jointTransform = jointTransform + Rotx4(joint->GetAngle());
			break;
		case rotation::Y:
			jointTransform = jointTransform + Roty4(joint->GetAngle());
			break;
		case rotation::Z:
			jointTransform = jointTransform + Rotz4(joint->GetAngle());
			break;
	}
	currentTransform = currentTransform * jointTransform;
	float R[12];
	matrixToArray(R, currentTransform);
	float ps[3];

	vect4ToArray(ps, currentTransform.col(3));
	if(joint->GetSon())
	{
		dsDrawSphere (ps, R, 0.05f);
	}
	else
	{
		float sides[3] = {effectorWidth_, effectorWidth_, effectorWidth_};
		dsDrawBox(ps, R, sides);
	}

	//draw line between positions
	if(joint->GetParent())
	{
		//dsDrawLine(from, ps);
		Vector3 trans(currentTransform.block<3,1>(0,3) - vFrom);
		
		matrices::vect3ToArray(from, vFrom + (trans / 2.));
		trans.normalize();
		Matrix3 transformCube;
		GetRotationMatrix(unitz, trans, transformCube);
		matrix3ToArray(R, transformCube);
		dsDrawCapsule(from, R, (float)(offset.norm() - 0.01f), width_);
	}
	if(tree_->IsAnchored())
	{
		dsSetColor(0.0,1.0,0.0);
		// draw target
		double ps[3];
		double Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
		tree_->GetTarget(ps);
		//dsDrawSphereD (ps, Identity, 0.2f);
	}
}


