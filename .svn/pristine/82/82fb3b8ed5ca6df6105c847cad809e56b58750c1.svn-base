#include "PostureManagerImpl.h"

#include "posture/PostureCriteriaToeOffBoundary.h"
#include "posture/PostureCriteriaToeOffJointLimit.h"
#include "posture/PostureCriteriaToeOffGait.h"
#include "posture/PostureCriteriaToeOnGait.h"
#include "posture/PostureCriteriaToeOnCOM.h"
#include "sampling/SampleGenerator.h"

#include "API/RobotI.h"
#include "kinematic/Robot.h"

#include "MatrixDefs.h"

using namespace manip_core;
using namespace manip_core::enums;
using namespace matrices;

PostureManagerImpl::PostureManagerImpl(const World& world)
	: pSolver_(world)
	, initialized_(false)
	, spiderGait_(0)
{
	// NOTHING
}

PostureManagerImpl::~PostureManagerImpl()
{
	if (spiderGait_)
	{
		delete spiderGait_;
	}
}

void PostureManagerImpl::Release()
{
	delete this;
}

void PostureManagerImpl::AddTrajectoryPoint(const float time,const  double* transform)
{
	matrices::Vector3 transf;
	matrices::arrayToVect3(transform, transf);
	trajectory_.AddCheckPoint(time, transf);
}

void PostureManagerImpl::ResetTrajectory()
{
	trajectory_.Reset();
}



void PostureManagerImpl::AddPostureCriteria(const enums::postureCriteria::ePostureCriteria criteria)
{
	switch(criteria)
	{
		case postureCriteria::toeOffBoundary:
			{
				pSolver_.AddToeOffCriteria(new PostureCriteriaToeOffBoundary());
				break;
			}
		case postureCriteria::toeOnCOM:
			{
				pSolver_.AddToeOnCriteria(new PostureCriteriaToeOnCOM());
				break;
			}
		case postureCriteria::toeOffJointLimit:
			{
				pSolver_.AddToeOffCriteria(new PostureCriteriaToeOffJointLimit());
				break;
			}
		case postureCriteria::toeOffSpiderGait:
			{
				if (spiderGait_ == 0)
				{
					spiderGait_ = new SpiderGait();
				}
				pSolver_.AddToeOffCriteria(new PostureCriteriaToeOffGait(spiderGait_));
				break;
			}
		case postureCriteria::toeOnSpiderGait:
			{
				if (spiderGait_ == 0)
				{
					spiderGait_ = new SpiderGait();
				}
				pSolver_.AddToeOnCriteria(new PostureCriteriaToeOnGait(spiderGait_));
				break;
			}
		default:
			break;
	}
}

void PostureManagerImpl::SetJumpToTarget(const bool jump)
{
	pSolver_.SetJumpToTarget(jump);
}


void PostureManagerImpl::RegisterPostureCreatedListenerI(PostureCreatedListenerI* listener)	
{
	pSolver_.RegisterPostureListener(*listener);
}

void PostureManagerImpl::UnRegisterPostureCreatedListenerI(PostureCreatedListenerI* listener)
{
	pSolver_.UnregisterPostureListener(*listener);
}

void PostureManagerImpl::InitSamples(const RobotI* robot, int nbSamples)
{
	assert(robot);
	Robot * rob = (static_cast<const Robot*>(robot))->Clone();
	SampleGenerator* sg = SampleGenerator::GetInstance();
	sg->GenerateSamples(*rob, nbSamples);
	initialized_ = true;
	delete rob;
}

void PostureManagerImpl::Compute(const RobotI* robot, int nbSamples)
{
	assert(robot);
	Robot * rob = (static_cast<const Robot*>(robot))->Clone();
	if(!initialized_)
	{
		InitSamples(rob, nbSamples);
	}// TODO : this is just horrible. Remove sample generation
	pSolver_.CreatePostures(*rob, trajectory_);
	//pSolver_.CreatePostures2(*rob, trajectory_);
}

void PostureManagerImpl::ComputeOnline(const RobotI* robot, int nbSamples)
{
	assert(robot);
	Robot * rob = (static_cast<const Robot*>(robot))->Clone();
	if(!initialized_)
	{
		InitSamples(rob, nbSamples);
	}// TODO : this is just horrible. Remove sample generation
	pSolver_.CreatePostures2(*rob, trajectory_);
}

void PostureManagerImpl::ComputeThird(const RobotI* robot, int nbSamples)
{
	assert(robot);
	Robot * rob = (static_cast<const Robot*>(robot))->Clone();
	if(!initialized_)
	{
		InitSamples(rob, nbSamples);
	}// TODO : this is just horrible. Remove sample generation
	pSolver_.CreatePostures3(*rob, trajectory_);
}

T_CubicTrajectory PostureManagerImpl::NextPosture(RobotI* robot, double* direction, bool closestDistance)
{
	Vector3 dir;
	matrices::arrayToVect3(direction, dir);
	assert(initialized_);
	Robot * rob = (static_cast<Robot*>(robot));
	return pSolver_.NextTrajectory(*rob, dir, false, closestDistance);
}

void PostureManagerImpl::Update(const unsigned long time)
{
	if (spiderGait_)
	{
		spiderGait_->Update(time);
	}
}

#ifdef PROFILE
void PostureManagerImpl::Log() const
{
	pSolver_.Log();
}
#endif

