
#include "SampleGenerator.h"
#include "SampleGeneratorVisitor_ABC.h"
#include "Sample.h"
#include "Tree.h"
#include "Joint.h"
#include "Pi.h"
#include "Filter_ABC.h"

#include <vector>
#include "time.h"

using namespace matrices;
using namespace std;



void GenerateJointAngle(Joint* joint)
{
	int minTheta, maxTheta;

	minTheta = (int)(joint->GetMinTheta()*RadiansToDegrees);
	maxTheta = (int)(joint->GetMaxTheta()*RadiansToDegrees);

	joint->SetTheta((rand() % ( maxTheta-minTheta + 1) + minTheta ) * DegreesToRadians);
}

struct PImpl
{
	PImpl()
	{
		// NOTHING
	}

	~PImpl()
	{
		// NOTHING
	}
	
	typedef std::vector<Sample> LSamples;
	typedef LSamples::const_iterator CITLSamples;
	typedef LSamples::iterator ITLSamples;

	void GenerateSample(Tree& tree)
	{
		Joint* j = tree.GetRoot();
		while(j)
		{
			GenerateJointAngle(j);
			j = j->pChild_;
		}
		tree.Compute();tree.ComputeJacobian();
		samples_.push_back(Sample(tree));
	}

	LSamples samples_;
};

SampleGenerator *SampleGenerator::instance = 0;

SampleGenerator::SampleGenerator()
	: pImpl_(new PImpl)
{
	srand((unsigned int)(time(0))); //Init Random generation
}

SampleGenerator::~SampleGenerator()
{
	// NOTHING
}


void SampleGenerator::GenerateSamples(Tree& tree, int nbSamples)
{
	Sample init(tree);
	assert(nbSamples > 0);
	//pImpl_->Reset();
	for(int i = 0; i < nbSamples; ++i)
	{
		pImpl_->GenerateSample(tree);
	}
	init.LoadIntoTree(tree);
}

void SampleGenerator::Request(SampleGeneratorVisitor_ABC& visitor, const Filter_ABC& filter) const
{
	for(PImpl::ITLSamples it = pImpl_->samples_.begin(); it != pImpl_->samples_.end(); ++it)
	{
		if( filter.ApplyFilter(*it) )
			visitor.Visit(*it);
	}
}


void SampleGenerator::Request(SampleGeneratorVisitor_ABC& visitor) const
{
	for(PImpl::ITLSamples it = pImpl_->samples_.begin(); it != pImpl_->samples_.end(); ++it)
	{
			visitor.Visit(*it);
	}
}

