
#include "Robot.h"
#include "RobotVisitor_ABC.h"
#include "Tree.h"

#include "World.h"

#include "IKSolver.h"

#include <vector>

using namespace matrices;
using namespace Eigen;

using namespace std;

struct RobotPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	RobotPImpl(const Matrix4& transform)
	{
		toWorldCoo_ = transform;
		toRobotCoo_ = transform.inverse();
	}

	~RobotPImpl()
	{
		for( T_TreeIT it = trees_.begin(); it!= trees_.end(); ++it)
		{
			delete(*it);
		}
	}

	IKSolver ikSolver_;
	Matrix4 toRobotCoo_;
	Matrix4 toWorldCoo_;

	typedef vector<Tree*> T_Tree;
	typedef T_Tree::iterator T_TreeIT;
	typedef T_Tree::const_iterator T_TreeCIT;
	T_Tree trees_;
};

Robot::Robot(const Matrix4& transform)
	: pImpl_(new RobotPImpl(transform))

{
	// NOTHING
}

Robot::~Robot()
{
	// NOTHING
}

void Robot::Accept(RobotVisitor_ABC& visitor) const
{
	for( RobotPImpl::T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		visitor.Visit(*(*it));
	}
}

void Robot::AddTree( Tree* tree )
{
	assert(tree);
	tree->Init();
	tree->ToRest();
	tree->Compute();
	tree->directionForce_ = new Vector3(0,0,1);
	tree->directionVel_ = new Vector3(1,0,0);

	pImpl_->trees_.push_back(tree);
}

void Robot::Move( const matrices::Vector3& direction, const World& world )
{
	Vector3 target;
	for( RobotPImpl::T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		if( world.GetTarget( pImpl_->toWorldCoo_, **it, direction, target ))
		{
			// translate target coordinates to robo coordinates
			target = matrix4TimesVect3(pImpl_->toRobotCoo_, target);
			pImpl_->ikSolver_.StepForceManipulability(**it, target, direction );
			//pImpl_->ikSolver_.Step(**it, target );
		}
	}
}

void Robot::Rest()
{
	Vector3 target;
	for( RobotPImpl::T_TreeIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		(*it)->ToRest();
	}
}


const matrices::Matrix4& Robot::ToWorldCoordinates() const
{
	return pImpl_->toWorldCoo_;
}

const matrices::Matrix4& Robot::ToRobotCoordinates() const
{
	return pImpl_->toRobotCoo_;
}

void Robot::Translate( const matrices::Vector3& direction )
{
	pImpl_->toWorldCoo_.block(0,3,3,1) = pImpl_->toWorldCoo_.block(0,3,3,1) + direction;
	pImpl_->toRobotCoo_.block(0,3,3,1) = pImpl_->toRobotCoo_.block(0,3,3,1) - direction;
}



