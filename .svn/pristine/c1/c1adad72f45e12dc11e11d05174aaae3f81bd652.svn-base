
#include "DrawRobot.h"
#include "DrawTree.h"
#include "DrawSupportPolygon.h"

#include "kinematic/Robot.h"
#include "kinematic/SupportPolygon.h"
#include "MatrixDefs.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#include <vector>

using namespace std;
using namespace matrices;

struct PImpl
{
	PImpl(const Robot& robot)
		:robot_(&robot)
		,drawSupport_(false)
	{
		//NOTHING
	}

	~PImpl()
	{
		//NOTHING
	}

	const Robot* robot_;

	typedef vector<DrawTree> T_Tree;
	typedef T_Tree::iterator T_TreeIT;
	typedef T_Tree::const_iterator T_TreeCIT;
	T_Tree drawTrees_;
	bool drawSupport_;
};



//TODO listener in case of adding new trees
DrawRobot::DrawRobot(const Robot& robot)
	: pImpl_(new PImpl(robot))
{
	robot.Accept(*this);
	const Tree* trunk = robot.GetTorso();
	if(trunk)
	{
		pImpl_->drawTrees_.push_back(DrawTree(*trunk));
	}
}

DrawRobot::~DrawRobot()
{
	// TODO
}

void DrawRobot::ToggleSupportPolygon(bool onoff)
{
	pImpl_->drawSupport_ = onoff;
}


void DrawRobot::Draw() const
{
	const Matrix4& currentTransform(pImpl_->robot_->ToWorldCoordinates());
	for(PImpl::T_TreeCIT it = pImpl_->drawTrees_.begin(); it!= pImpl_->drawTrees_.end(); ++it)
	{
		it->Draw(currentTransform);
	}
	if(pImpl_->drawSupport_)
	{
		Vector3 com = matrices::matrix4TimesVect3( pImpl_->robot_->ToWorldCoordinates(), pImpl_->robot_->ComputeCom());
	//Vector3 com = pRobot->ComputeCom();
		float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
		float t[3];
		t[0] = (float)(com(0));
		t[1] = (float)(com(1));
		t[2] = (float)(com(2));
		dsDrawSphere(t, Identity, 0.1f);
		SupportPolygon sp(*pImpl_->robot_);
		DrawSupportPolygon dsp(*pImpl_->robot_, sp);
		dsp.Draw();
	}
}

void DrawRobot::Visit(const Tree& tree, const Joint* anchor)
{
	pImpl_->drawTrees_.push_back(DrawTree(tree));
}

