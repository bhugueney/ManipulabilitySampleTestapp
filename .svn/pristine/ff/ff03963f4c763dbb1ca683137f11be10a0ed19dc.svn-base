
#include "Robot.h"
#include "RobotVisitor_ABC.h"
#include "Tree.h"

#include "World.h"

#include "IKSolver.h"
#include "ForceManipulabilityConstraint.h"

#include <vector>

using namespace matrices;
using namespace Eigen;

using namespace std;

struct RobotPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	RobotPImpl(const Matrix4& transform)
	{
		toWorldCoo_ = transform;
		toRobotCoo_ = transform.inverse();
	}

	~RobotPImpl()
	{
		for( T_TreeIT it = trees_.begin(); it!= trees_.end(); ++it)
		{
			delete(*it);
		}
	}

	IKSolver ikSolver_;
	Matrix4 toRobotCoo_;
	Matrix4 toWorldCoo_;

	typedef vector<Tree*> T_Tree;
	typedef T_Tree::iterator T_TreeIT;
	typedef T_Tree::const_iterator T_TreeCIT;
	T_Tree trees_;
};

Robot::Robot(const Matrix4& transform)
	: pImpl_(new RobotPImpl(transform))
	, numTrees_(0)
{
	// which constraints are we going to use ?
	pImpl_->ikSolver_.Register(new ForceManipulabilityConstraint);
}

Robot::~Robot()
{
	// NOTHING
}

void Robot::Accept(RobotVisitor_ABC& visitor) const
{
	for( RobotPImpl::T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		visitor.Visit(*(*it));
	}
}

void Robot::AddTree( Tree* tree )
{
	assert(tree);
	tree->Init();
	tree->Compute();
	tree->directionForce_ = Vector3(0,0,1);
	tree->directionVel_ = Vector3(1,0,0);
	++ numTrees_;
	pImpl_->trees_.push_back(tree);
}

const unsigned int Robot::GetNumTrees() const
{
	return numTrees_;
}


Tree* Robot::GetTree(Tree::TREE_ID id) const
{
	return id >= numTrees_ ? 0 : pImpl_->trees_[id];
}


void Robot::Move( const matrices::Vector3& direction, const World& world )
{
	//Vector3 direction = (matrix4TimesVect3(pImpl_->toRobotCoo_, dir));
	//direction.normalize();
	Vector3 target;
	for( RobotPImpl::T_TreeIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		if( (*it)->IsLocked() )
		{
			target = matrix4TimesVect3(pImpl_->toRobotCoo_, (*it)->GetTarget());
			if(world.Intersect((**it), target))
			{
				//pImpl_->ikSolver_.StepForceManipulability(**it, target, direction );
				pImpl_->ikSolver_.StepClamping(**it, target, direction );
			}
			else 
			{
				(*it)->UnLockTarget();
			}
		}
		else if( world.GetTarget( *this, **it, direction, target ))
		{
			// translate target coordinates to robo coordinates
			Vector3 robotTarget = matrix4TimesVect3(pImpl_->toRobotCoo_, target);
			//if ( pImpl_->ikSolver_.StepForceManipulability(**it, robotTarget, direction ) )
			if ( pImpl_->ikSolver_.StepClamping(**it, robotTarget, direction ) )
			{
				(*it)->LockTarget(target);
			}
			//pImpl_->ikSolver_.Step(**it, target );
		}
		else
		{
			//pImpl_->ikSolver_.StepForceManipulability(**it, (*it)->referenceTarget_, direction);
			pImpl_->ikSolver_.StepClamping(**it, (*it)->referenceTarget_, direction);
		}
	}
}

void Robot::Reset()
{
	pImpl_->toWorldCoo_.block(0,3,3,1) = pImpl_->toWorldCoo_.block(0,3,3,1) - pImpl_->toWorldCoo_.block(0,3,3,1);
	Rest();
}


void Robot::Rest()
{
	Vector3 target;
	for( RobotPImpl::T_TreeIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		(*it)->ToRest();
	}
}


const matrices::Matrix4& Robot::ToWorldCoordinates() const
{
	return pImpl_->toWorldCoo_;
}

const matrices::Matrix4& Robot::ToRobotCoordinates() const
{
	return pImpl_->toRobotCoo_;
}

void Robot::Translate( const matrices::Vector3& direction )
{
	pImpl_->toWorldCoo_.block(0,3,3,1) = pImpl_->toWorldCoo_.block(0,3,3,1) + direction;
	pImpl_->toRobotCoo_.block(0,3,3,1) = pImpl_->toRobotCoo_.block(0,3,3,1) - direction;
}

Robot* Robot::Clone() const
{
	Robot* res = new Robot(pImpl_->toWorldCoo_);
	for( RobotPImpl::T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		res->AddTree((*it)->Clone());
	}
	return res;
}

