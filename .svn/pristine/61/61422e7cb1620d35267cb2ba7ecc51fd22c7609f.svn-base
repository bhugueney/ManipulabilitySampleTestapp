
#include "Joint.h"
#include "Pi.h"
#include "MatrixDefs.h"

#include <math.h>

using namespace matrices;


Joint::Joint(const Vector3& attach, const Vector3& iRotAxis, Purpose purpose, NUMBER minTheta, NUMBER maxTheta, NUMBER restAngle, Rotation rot)
	: r_			(0, 0, 0)
	, purpose_		(purpose)
	, attach_		(attach) 
	, v_			(iRotAxis) // Rotation axis when joints at zero angles
	, theta_		(0)
	, pRealparent_	(0)
	, restAngle_	(restAngle)
	, minTheta_		(minTheta)
	, maxTheta_		(maxTheta)
	, pChild_		(0)
	, rot_(rot)
{
	// NOTHING
}

Joint::Joint(const Vector3& attach, const Vector3& iRotAxis, Purpose purpose, NUMBER restAngle, Rotation rot)
	: r_			(0, 0, 0)
	, purpose_		(purpose)
	, attach_		(attach) 
	, v_			(iRotAxis) // Rotation axis when joints at zero angles
	, theta_		(0)
	, pRealparent_	(0)
	, restAngle_	(restAngle)
	, minTheta_		(-Pi)
	, maxTheta_		(Pi)
	, pChild_		(0)
	, rot_(rot)
{
	// NOTHING
}

Joint::~Joint()
{
	//NOTHING
}

NUMBER Joint::AddToTheta(const NUMBER delta)
{ 
	NUMBER newTheta = theta_ + delta;
	if(newTheta > maxTheta_)
	{
		theta_ = maxTheta_;
	}
	else if (newTheta < minTheta_)
	{
		theta_ = minTheta_;
	}
	else
	{
		theta_ = newTheta;
	}
	return newTheta - theta_;
}


// Compute the global position of a single Joint
void Joint::ComputeS(void)
{
	Joint* y = this->pRealparent_;
	Joint* w = this;
	s_ = r_;							// Initialize to local (relative) position
	while (y) {
		Rotate(y->v_, s_, y->theta_);
		y = y->pRealparent_;
		w = w->pRealparent_;
		s_ += w->r_;
	}
}

// Compute the global rotation axis of a single Joint
void Joint::ComputeW(void)
{
	Joint* y = this->pRealparent_;
	w_ = v_;							// Initialize to local rotation axis
	while (y) {
		Rotate(y->v_, w_, y->theta_);
		y = y->pRealparent_;
	}
}

void Joint::InitJoint()
{
	theta_ = restAngle_;
}

void Joint::ToRest()
{
	theta_ = restAngle_;
}

Joint* Joint::Clone() const
{
	return new Joint(attach_, v_, purpose_, minTheta_, maxTheta_, restAngle_, rot_);
}
