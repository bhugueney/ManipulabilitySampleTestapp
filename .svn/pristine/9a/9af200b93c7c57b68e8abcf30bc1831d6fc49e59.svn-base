
#include "Robot.h"
#include "RobotVisitor_ABC.h"
#include "Tree.h"

#include "World.h"
#include "Com.h"
#include "ComVisitor_ABC.h"

#include "IKSolver.h"
#include "ForceManipulabilityConstraint.h"

using namespace matrices;
using namespace Eigen;

using namespace std;

struct RobotPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	RobotPImpl(const Matrix4& transform)
		: torso_(0)
	{
		SetTransform(transform);
	}

	~RobotPImpl()
	{
		for(Robot::T_TreeIT it = trees_.begin(); it!= trees_.end(); ++it)
		{
			delete(*it);
		}
		if(torso_)
		{
			delete(torso_);
		}
	}

	void SetTransform(const Matrix4& transform)
	{
		toWorldCoo_ = transform;
		toRobotCoo_ = transform.inverse();
	}

	IKSolver ikSolver_;
	Matrix4 toRobotCoo_;
	Matrix4 toWorldCoo_;

	Robot::T_Tree trees_;
	Tree* torso_;
};

struct ComVisitor : public ComVisitor_ABC
{
	 ComVisitor()
		: ComVisitor_ABC()
		, sigmaAi_(0.f)
		, positionSum_(0, 0, 0)
	 {
		// NOTHING
	 }
	~ComVisitor()
	 {
		// NOTHING
	 }

	// source http://fr.wikipedia.org/wiki/Fonctions_de_Leibniz#Fonction_vectorielle_de_Leibniz
	virtual void VisitCom(const matrices::Vector3& position, const float& weight)
	{
		positionSum_ += weight * position;
		sigmaAi_ += weight;
	}

	Vector3 GetCom() const
	{
		return ( 1.f / sigmaAi_ ) * positionSum_;
	}

	float sigmaAi_;
	Vector3 positionSum_;;
};

Robot::Robot(const Matrix4& transform)
	: pImpl_(new RobotPImpl(transform))
	, numTrees_(0)
	, currentGait_(0)
{
	// which constraints are we going to use ?
	pImpl_->ikSolver_.Register(new ForceManipulabilityConstraint);
}

void Robot::SetPosOri(const matrices::Matrix4& transform)
{
	pImpl_->SetTransform(transform);
}


Robot::~Robot()
{
	// NOTHING
}

const Tree* Robot::GetTorso() const
{
	return pImpl_->torso_;
}


void Robot::Accept(RobotVisitor_ABC& visitor) const
{
	for(T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		visitor.Visit(*(*it));
	}
}

void Robot::AddTree(Tree* tree)
{
	assert(tree);
	tree->Init();
	tree->Compute();
	tree->directionForce_ = Vector3(0,0,1);
	tree->directionVel_ = Vector3(1,0,0);
	++ numTrees_;
	pImpl_->trees_.push_back(tree);
}

void Robot::AddTorsoAndHead(Tree* tree)
{
	assert(tree);
	tree->Init();
	tree->Compute();
	if(!pImpl_->torso_)
	{
		pImpl_->torso_ = tree;
	}
}

const unsigned int Robot::GetNumTrees() const
{
	return numTrees_;
}


Tree* Robot::GetTree(Tree::TREE_ID id) const
{
	return id >= numTrees_ ? 0 : pImpl_->trees_[id];
}

matrices::Vector3 Robot::ComputeCom() const
{
	ComVisitor visitor;
	for(T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		(*it)->AcceptComVisitor(&visitor);
	}
	if(pImpl_->torso_)
	{
		pImpl_->torso_->AcceptComVisitor(&visitor);
	}
	return visitor.GetCom();
}


void Robot::Move(const matrices::Vector3& direction, const World& world)
{
	//Vector3 direction = (matrix4TimesVect3(pImpl_->toRobotCoo_, dir));
	//direction.normalize();
	Vector3 target;
	for(T_TreeIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		if((*it)->IsLocked())
		{
			target = matrix4TimesVect3(pImpl_->toRobotCoo_, (*it)->GetTarget());
			//if(world.Intersect((**it), target))
			if(world.IsReachable(*this, (**it), (*it)->GetTarget()))
			{
				//pImpl_->ikSolver_.StepForceManipulability(**it, target, direction);
				pImpl_->ikSolver_.StepClamping(**it, target, direction);
			}
			else 
			{
				(*it)->UnLockTarget();
			}
		}
		else if(world.GetTarget(*this, **it, direction, target))
		{
			// translate target coordinates to robo coordinates2
			Vector3 robotTarget = matrix4TimesVect3(pImpl_->toRobotCoo_, target);
			//if (pImpl_->ikSolver_.StepForceManipulability(**it, robotTarget, direction))
			if (pImpl_->ikSolver_.StepClamping(**it, robotTarget, direction))
			{
				(*it)->LockTarget(target);
			}
			//pImpl_->ikSolver_.Step(**it, target);
		}
		else
		{
			//pImpl_->ikSolver_.StepForceManipulability(**it, (*it)->referenceTarget_, direction);
			pImpl_->ikSolver_.StepClamping(**it, (*it)->referenceTarget_, direction);
		}
	}
}

void Robot::Reset()
{
	pImpl_->toWorldCoo_.block(0,3,3,1) = pImpl_->toWorldCoo_.block(0,3,3,1) - pImpl_->toWorldCoo_.block(0,3,3,1);
	Rest();
}


void Robot::Rest()
{
	Vector3 target;
	for(T_TreeIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		(*it)->ToRest();
	}
}


const matrices::Matrix4& Robot::ToWorldCoordinates() const
{
	return pImpl_->toWorldCoo_;
}

const matrices::Matrix4& Robot::ToRobotCoordinates() const
{
	return pImpl_->toRobotCoo_;
}

void Robot::Translate(const matrices::Vector3& direction)
{
	pImpl_->toWorldCoo_.block(0,3,3,1) = pImpl_->toWorldCoo_.block(0,3,3,1) + direction;
	pImpl_->toRobotCoo_.block(0,3,3,1) = pImpl_->toRobotCoo_.block(0,3,3,1) - direction;
}

const Robot::T_Tree& Robot::GetTrees() const
{
	return pImpl_->trees_;
}

Robot* Robot::Clone() const
{
	Robot* res = new Robot(pImpl_->toWorldCoo_);
	for(T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		res->AddTree((*it)->Clone());
	}
	res->SetGait(gait_);
	res->currentGait_ = currentGait_;
	return res;
}

void  Robot::SetGait( const Gait& gait)
{
	gait_ = gait; // TODO check that it is a correct gait
}

const Robot::Gait& Robot::GetGait()
{
	return gait_;
}

Tree::TREE_ID Robot::GetCurrentGait() const
{
	assert(gait_.size() >= 1);
	return gait_[currentGait_];
}

Tree::TREE_ID Robot::GetNextGait() const
{
	assert(gait_.size() >= 2);
	return gait_[(currentGait_ + 1) % gait_.size()];
}

Tree::TREE_ID Robot::IncreaseGait()
{
	assert(gait_.size() >= 2);
	currentGait_ = (currentGait_ + 1) % gait_.size();
	return gait_[currentGait_];
}


