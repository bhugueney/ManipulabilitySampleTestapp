
#include "Tree.h"
#include "Joint.h"
#include "MatrixDefs.h"

using namespace matrices;

Tree::Tree()
{
	root = 0;
	nJoint = nEffector = nJoint = 0;
}

void Tree::SetSeqNum(Joint* joint)
{
	switch (joint->purpose_) {
	case JOINT:
		joint->seqNumJoint_ = nJoint++;
		joint->seqNumEffector_ = -1;
		break;
	case EFFECTOR:
		joint->seqNumJoint_ = -1;
		joint->seqNumEffector_ = nEffector++;
		break;
	}
}

void Tree::InsertRoot(Joint* root)
{
	assert(nJoint == 0);
	nJoint++;
	Tree::root = root;
	root->r_ = root->attach_;
	assert(!(root->pChild_));
	SetSeqNum(root);
}

void Tree::InsertChild(Joint* parent, Joint* child)
{
	assert(parent);
	parent->pChild_ = child;
	child->pRealparent_ = parent;
	child->r_ = child->attach_ - child->pRealparent_->attach_;
	assert( !(child->pChild_) );
	SetSeqNum(child);
}

// Search recursively below "Joint" for the Joint with index value.
Joint* Tree::SearchJoint(Joint* joint, int index)
{
	Joint* ret(0);
	if (joint != 0)
	{
		if (joint->seqNumJoint_ == index)
		{
			ret = joint;
		}
		else
		{
			ret = SearchJoint(joint->pChild_, index);
		}
	} 
	return ret;
}

// Search recursively below Joint for the end effector with the index value
Joint* Tree::SearchEffector(Joint* joint, int index)
{
	Joint* ret(0);
	if (joint != 0)
	{
		if (joint->seqNumEffector_ == index)
		{
			ret = joint;
		} 
		else
		{
			ret = SearchEffector(joint->pChild_, index);
		}
	}
	return ret;
}

// Get the joint with the index value
Joint* Tree::GetJoint(int index)
{
	return SearchJoint(root, index);
}

// Get the end effector for the index value
Joint* Tree::GetEffector(int index)
{
	return SearchEffector(root, index);
}

// Returns the global position of the effector.
const Vector3& Tree::GetEffectorPosition(int index)
{
	Joint* effector = GetEffector(index);
	assert(effector);
	return (effector->s_);  
}

void Tree::ComputeTree(Joint* joint)
{
	if (joint != 0) {
		joint->ComputeS();
		joint->ComputeW();
		ComputeTree(joint->pChild_);
	}
}

void Tree::Compute(void)
{ 
	ComputeTree(root); 
}

// Recursively initialize tree below the Joint
void Tree::InitTree(Joint* joint)
{
	if (joint != 0)
	{
		joint->InitJoint();
		InitTree(joint->pChild_);
	}
}

// Initialize all Joints in the tree
void Tree::Init(void)
{
	InitTree(root);
}
