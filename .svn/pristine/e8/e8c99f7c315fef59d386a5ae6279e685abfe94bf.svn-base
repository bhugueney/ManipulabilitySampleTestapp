
#include "World.h"
#include "ObstacleVisitor_ABC.h"

#include "Intersection.h"
#include "Obstacle.h"
#include "kinematic/Tree.h"
#include "kinematic/Robot.h"

#include <vector>
using namespace std;


//TODO : alignement error with obstacle vector ... hence the ugly stuff
struct WorldPImpl
{
	WorldPImpl()
	{
		//NOTHING
	}

	~WorldPImpl()
	{
		for( T_ObstacleIT it = obstacles_.begin(); it!= obstacles_.end(); ++it)
		{
			delete(*it);
		}
	}

	Intersection intersection_;

	typedef vector<Obstacle*> T_Obstacle;
	typedef T_Obstacle::iterator T_ObstacleIT;
	typedef T_Obstacle::const_iterator T_ObstacleCIT;
	T_Obstacle obstacles_;
};

using namespace matrices;
using namespace Eigen;

World::World()
	: pImpl_(new WorldPImpl())
{
	//NOTHING
}

World::~World()
{
	//NOTHING
}

void World::AddObstacle(Obstacle* obstacle)
{
	assert(obstacle);
	pImpl_->obstacles_.push_back(obstacle);
}

void World::Accept( ObstacleVisitor_ABC& visitor) const
{
	for( WorldPImpl::T_ObstacleIT it = pImpl_->obstacles_.begin(); it!= pImpl_->obstacles_.end(); ++it)
	{
		visitor.Visit(*(*it));
	}
}

bool World::GetTarget( const Robot& robot, const Tree& tree, const Vector3& direction, Vector3& target) const
{
	//TODO : pattern patron pour choisir méthode de sélection 
	//phase 1 : le premier qui intersecte ...
	for( WorldPImpl::T_ObstacleIT it = pImpl_->obstacles_.begin(); it!= pImpl_->obstacles_.end(); ++it)
	{
		if( pImpl_->intersection_.Intersect(robot, tree, *(*it), target ) )
		{
			return true;
		}
	}
	return false;
}

bool World::Intersect(const Tree& tree, const Vector3& target ) const
{
	return pImpl_->intersection_.Intersect(tree, target);
}
