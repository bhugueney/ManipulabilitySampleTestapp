#include "RootTrajectory.h"
#include "Simulation.h"
#include "Draw/DrawSpline.h"

using namespace matrices;

namespace
{
	
	typedef std::vector<matrices::Vector3,Eigen::aligned_allocator<matrices::Vector3>> T_Vector3;
	typedef T_Vector3::const_iterator CIT_Vector3;
}

RootTrajectory::RootTrajectory(curve_abc_t* spline)
	: spline_(spline)
	, previous_(1,0,0)
{
	// NOTHING
}

RootTrajectory::~RootTrajectory()
{
	delete spline_;
	// NOTHING
}

void RootTrajectory::Update(const Timer::t_time t, const Timer::t_time dt)
{
	Simulation* sg = Simulation::GetInstance();
	if(sg->simpParams_.rootTrajectory_)
	{
		manip_core::RobotI* robot = sg->pRobot;
		Vector3 currentPos((*spline_)(std::min(t/2, spline_->max())));
		double transf[16];
		robot->ToWorldCoordinates(transf);
		currentPos = currentPos - Vector3(transf[3], transf[7], transf[11]);
		sg->motionHandler_.MoveBy(currentPos);
		// ok now compute rotation
		if(currentPos.norm() > 0.0001)
		{
			currentPos.normalize();
			matrices::Matrix3 rotation;
			//matrices::GetRotationMatrix(currentPos, previous_, rotation);
			matrices::GetRotationMatrix(previous_, currentPos , rotation);
			previous_ = currentPos;
			sg->motionHandler_.Rotate(rotation);
		}

		if(sg->simpParams_.drawSplines_)
		{
			DrawSpline ds(*spline_);
			ds.Draw();
		}
	}
}
