#include "RobotRootSampler.h"

#include "kinematic/Tree.h"

#include "sampling/SampleGeneratorVisitor_ABC.h"
#include "sampling/SampleGenerator.h"
#include "sampling/Sample.h"

#include "world/ObstacleVisitor_ABC.h"
#include "world/Intersection.h"

#include "FilterDistance.h"
#include "FilterDistanceObstacle.h"

#include <algorithm>    // std::min, max
#include <stdlib.h>     /* srand, rand */
#include <vector>     /* srand, rand */

using namespace matrices;

namespace
{
	Boundaries ComputeBoundaries(const Robot& robot)
	{
		Boundaries b;
		b.IsBounded_ = false;
		b.minX_ = -10000;
		b.maxX_ =  10000;
		b.minY_ = b.minX_;
		b.maxY_ = b.maxX_;
		b.minZ_ = b.minX_;
		b.maxZ_ = b.maxX_ ;
		int i = 0; Tree* tempTree;
		const matrices::Matrix4& worldTransform = robot.ToWorldCoordinates();
		const matrices::Matrix4& robotTransform = robot.ToRobotCoordinates();
		int nbLocks = 0;
		for(Robot::T_TreeCIT it = robot.GetTrees().begin(); it != robot.GetTrees().end(); ++it)
		{
			tempTree = (*it);
			if(tempTree->IsLocked())
			{
				++nbLocks;
				// removing tree offset from center
				const matrices::Vector3 position = matrices::matrix4TimesVect3(worldTransform, tempTree->GetEffectorPosition(tempTree->GetNumEffector()-1)) - tempTree->GetRoot()->GetR();
				NUMBER radius = tempTree->GetBoundaryRadius();
				b.minX_ = std::max(b.minX_, position.x() - radius); 
				b.maxX_ = std::min(b.maxX_, position.x() + radius);
				b.minY_ = std::max(b.minY_, position.y() - radius); 
				b.maxY_ = std::min(b.maxY_, position.y() + radius);
				b.minZ_ = std::max(b.minZ_, position.z() - radius); 
				b.maxZ_ = std::min(b.maxZ_, position.z() + radius);
			}
		}
		const matrices::Vector3 rPos = matrices::matrix4TimesVect3(worldTransform, matrices::Vector3(0,0,0));
		if(    b.minX_ <= rPos.x() && rPos.x() <= b.maxX_
			&& b.minY_ <= rPos.y() && rPos.y() <= b.maxY_
			&& b.minZ_ <= rPos.z() && rPos.z() <= b.maxZ_)
		{
			b.solutionMayExists_ = true;
		}
		else
		{
			b.solutionMayExists_ = false;
		}
		b.IsBounded_ = nbLocks > 1;
		return b;
	}

	struct HandleLockedVisitor : SampleGeneratorVisitor_ABC
	{
		HandleLockedVisitor(const World& world)
			:world_(world)
			, currentBest_(0) {}

		~HandleLockedVisitor() {}

		virtual void Visit(const Robot& robot, Tree& tree, Sample& sample)
		{
			if(currentBest_ == 0 && !world_.IsColliding(robot, tree))
			{
				currentBest_ = &sample;
			}
		}
		Sample* currentBest_;
		const World& world_;
	};

	struct LockVisitor : public SampleGeneratorVisitor_ABC
	{
		LockVisitor(const Vector3& currentDir, const World& world)
			: currentBest_(0)
			, currentDir_(currentDir)
			, currentBestManip_(-100000)
			, world_(world) {}

		~LockVisitor() {}

	
		virtual void Visit(const Robot& robot, /*const*/ Tree& tree, Sample& sample, const Obstacle& obstacle)
		{
			NUMBER manip = sample.forceManipulabiliy(currentDir_);
			// colinear product btw surface and wanted dir. 
			Vector3 norm = obstacle.n_;
			Vector3 nDir = currentDir_;
			nDir.normalize();
			norm.normalize();
			if(robot.GetType() != manip_core::enums::robot::HumanEscalade && robot.GetType() != manip_core::enums::robot::HumanEllipse)
			{
				manip = manip * norm.dot(nDir);
			}
			if(manip >= currentBestManip_ && ( (tree.GetId() != 0 && tree.GetId() != 5) || sample.GetPosition()(0) > 0.3)
				&& ( (tree.GetId() != 2 && tree.GetId() != 2) || sample.GetPosition()(0) > 0))
			{
				Tree* testtree = tree.Clone() ;
				sample.LoadIntoTree(*testtree);
				if(!world_.IsColliding(robot, *testtree))
				{
					currentBest_ = &sample;
					currentBestManip_ = manip;
					obs_ = &obstacle;
				}
			}
		}
		const Obstacle* obs_;
		const Vector3 currentDir_;
		NUMBER currentBestManip_;
		Sample* currentBest_;
		const World& world_;
	};

	typedef std::pair<int, Sample*> Handle;
	typedef std::vector<Handle> T_Handle;
	bool CheckTree(Robot& robot, const World& world)
	{
		T_Handle handles;
		Tree* tempTree; int i = 0;
		SampleGenerator* sg = SampleGenerator::GetInstance();

		bool ok = true;
		for(Robot::T_TreeCIT it = robot.GetTrees().begin(); ok && it != robot.GetTrees().end(); ++it, ++i)
		{
			tempTree = (*it);
			if(tempTree->IsLocked())
			{
				HandleLockedVisitor hv(world);
				FilterDistance filter(0.05, *tempTree, matrices::matrix4TimesVect3(robot.ToRobotCoordinates(), tempTree->GetTarget()));
				sg->Request(robot, *tempTree, &hv, filter);
				if(hv.currentBest_)
				{
					handles.push_back(std::make_pair(i, hv.currentBest_));
				}
				else
				{
					ok = false;
				}
			}
		}
		if(ok)
		{
			for(T_Handle::const_iterator it = handles.begin(); it != handles.end();++it)
			{
				it->second->LoadIntoTree(*(robot.GetTree(it->first)));
			}
		}
		return ok;
	}

	struct ReachableObstaclesContainer : public ObstacleVisitor_ABC
	{
		ReachableObstaclesContainer(const World& world, const Tree& tree, const Robot& robot)
			: ObstacleVisitor_ABC()
			, world_(world)
			, tree_ (tree)
			, robot_(robot)
		{
			// NOTHING
		}

		~ReachableObstaclesContainer()
		{
			// NOTHING
		}

		virtual void Visit(const Obstacle& obstacle)
		{
			if(!obstacle.donttouch_ && world_.IsReachable(robot_, tree_, obstacle))
				obstacles_.push_back(&obstacle);
		}

		typedef std::vector<const Obstacle*> T_Obstacles;
		typedef T_Obstacles::const_iterator T_ObstaclesCIT;
		typedef T_Obstacles::iterator		T_ObstaclesIT;

		T_Obstacles obstacles_;
		const World& world_;
		const Tree&  tree_ ;
		const Robot& robot_;
	};

	bool LockTree(Robot& robot, const World& world, const matrices::Vector3& dir, const Tree::TREE_ID id)
	{
		if(!CheckTree(robot, world)) return false;
		Tree* tempTree = robot.GetTree(id);
		
		SampleGenerator* sg = SampleGenerator::GetInstance();
		// Collecting reachable obstacles
		ReachableObstaclesContainer obstacles(world, *tempTree, robot);
		world.Accept(obstacles);
		LockVisitor visitor(dir, world);
		Intersection intersect;
		bool ret = false;
		Robot* futureRob = robot.Clone();
		for(ReachableObstaclesContainer::T_ObstaclesCIT it = obstacles.obstacles_.begin(); it!= obstacles.obstacles_.end(); ++it)
		{
			Vector3 intersectionPoint;
			Vector3 treePositionWorld = matrix4TimesVect3(futureRob->ToWorldCoordinates(), tempTree->GetPosition());
			if(intersect.IntersectClosest(*futureRob, *tempTree, treePositionWorld, (*(*it)), intersectionPoint))
			{
				if((treePositionWorld - intersectionPoint).norm() < tempTree->GetBoundaryRadius())
				{
					FilterDistanceObstacle filter(0.1, *tempTree, (*(*it)), *futureRob, dir);
					//sg->Request(robot, tree, visitor, filter);
					sg->Request(robot, *tempTree, &visitor, filter, *(*it));
				}
			}
		}
		if(visitor.currentBest_)
		{
			Sample old(*tempTree);
			visitor.currentBest_->LoadIntoTree(*tempTree);
			tempTree->Compute();
			tempTree->direction_ = dir;
			tempTree->direction_.normalize();

			Vector3 samplePosition = matrices::matrix4TimesVect3(robot.ToWorldCoordinates(), tempTree->GetPosition() + visitor.currentBest_->GetPosition());
			tempTree->LockTarget(samplePosition, visitor.obs_);
			ret = true;
		}
		return ret;
	}
}

RobotRootSampler::RobotRootSampler(const World& world, const Robot& robot)
	: world_(world)
	, robot_(robot)
	, boundaries_(ComputeBoundaries(robot))
{
	// NOTHING
}

RobotRootSampler::~RobotRootSampler()
{
	// NOTHING
}


Robot* RobotRootSampler::GenerateSample() const
{
	int i = 0; Robot* rob = robot_.Clone();
	while(boundaries_.solutionMayExists_ && boundaries_.IsBounded_ && i < 1000)
	{
		NUMBER x = boundaries_.minX_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxX_-boundaries_.minX_)));
		NUMBER y = boundaries_.minY_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxY_-boundaries_.minY_)));
		NUMBER z = boundaries_.minZ_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxZ_-boundaries_.minZ_)));

		rob->MoveTo(matrices::Vector3(x, y, z));
		if(CheckTree(*rob, world_))
		{
			return rob;
		}
		++i;
	}
	delete rob;
	return 0;
}

Robot* RobotRootSampler::GenerateSampleAndContact(Tree::TREE_ID limbToTlock) const
{
	if(limbToTlock <0 || limbToTlock >= robot_.GetNumTrees())
	{
		return GenerateSample();
	}
	Robot* rob = robot_.Clone();
	if(robot_.GetTree(limbToTlock)->IsLocked())
	{
		Tree* tree = rob->GetTree(limbToTlock);
		tree->UnLockTarget();
		if(tree->targetReached_)
		{
			tree->targetReached_ = false;
		}
		RobotRootSampler offSampler(world_, *rob);
		Robot * res = offSampler.GenerateSample();
		delete rob;
		return res;
	}
	else
	{
		int i = 0;
		if(!boundaries_.IsBounded_)
		{
			if(LockTree(*rob, world_, Vector3(0,0,1), limbToTlock))
				return rob;
		}
		else
		{
			while(boundaries_.solutionMayExists_ && i < 1000)
			{
				++i;
				NUMBER x = boundaries_.minX_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxX_-boundaries_.minX_)));
				NUMBER y = boundaries_.minY_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxY_-boundaries_.minY_)));
				NUMBER z = boundaries_.minZ_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxZ_-boundaries_.minZ_)));
				matrices::Vector3 direction = rob->MoveTo(matrices::Vector3(x, y, z));
				if(LockTree(*rob, world_, direction, limbToTlock))
				{
					return rob;
				}
			}
		}
		delete rob;
		return 0;
	}
}


bool RobotRootSampler::SolutionMayExists(const matrices::Vector3& rPos) const
{
	return boundaries_.minX_ <= rPos.x() && rPos.x() <= boundaries_.maxX_
		&& boundaries_.minY_ <= rPos.y() && rPos.y() <= boundaries_.maxY_
		&& boundaries_.minZ_ <= rPos.z() && rPos.z() <= boundaries_.maxZ_;
}
