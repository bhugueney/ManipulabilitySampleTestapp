#include "Scorer.h"
#include "API/RobotI.h"
#include "API/TreeI.h"

using namespace manip_core;
using namespace statepostures;

ScorerHuman::ScorerHuman()
{
	// NOTHING
}

ScorerHuman::~ScorerHuman()
{
	// NOTHING
}

namespace
{
	void TransitionCoast(const std::vector<bool>& a, const std::vector<bool>& b, float& val)
	{
		//assert(a.size() == b.size());
		std::vector<bool>::const_iterator it2 = b.begin();
		int nbDiffs = 0;
		for(std::vector<bool>::const_iterator it = a.begin(); it!= a.end(); ++ it, ++it2)
		{
			if(*it != *it2)
				++nbDiffs;
		}
		val += nbDiffs * nbDiffs;
	}

	void ComputeState(const RobotI* posture, std::vector<bool>& values, float& val)
	{
		bool temp;
		for(unsigned int i=0; i < posture->GetNumTrees(); ++i)
		{
			temp = posture->GetTreeI(i)->IsAnchored();
			values.push_back(temp);
			if(!temp) ++val;
		}
	}
}

float ScorerHuman::operator()(const std::vector<RobotI*>& postures) const
{
	/*prefer states where most contacts are preserved. Do as follows:
	- Every transition gives one point (0 if same state)
	- Number of false members (ie not in contact) is the number of points given by the state
	- If transitions leads to a lot of changes penalize double
	*/
	if(postures.size() == 0) return 0.f;
	float val = 0;
	std::vector<bool>* previous = new std::vector<bool>();
	std::vector<bool>* current = new std::vector<bool>();
	std::vector<bool>* temp;
	for(std::vector<RobotI*>::const_iterator it = postures.begin(); it != postures.end(); ++it)
	{
		ComputeState((*it), *current, val);
		TransitionCoast(*previous, *current, val);
		previous->clear();
		temp = previous;
		previous = current;
		current = temp;
	}
	delete previous;
	delete current;
	return val;
}

float ScorerHuman::operator()(const std::vector<bool>& state) const
{
	/*prefer states where most contacts are preserved. Do as follows:
	- Every transition gives one point (0 if same state)
	*/
	float val = 0;
	for(std::vector<bool>::const_iterator it = state.begin(); it != state.end(); ++it)
	{
		if(*it) ++val;
	}
	return val;
}
	
