#include "OptimizeSpline.h"

#include "mosek/mosek.h" 

#include <Eigen/SparseCore>

#include <stdio.h>
#include <iostream>

namespace spline
{
struct OptimizePImpl
{
	OptimizePImpl()
	{
		/* Create the mosek environment. */
		r_ = MSK_makeenv(&env_,NULL);
		assert(r_ == MSK_RES_OK);
	}

	~OptimizePImpl()
	{
		// TODO : unload env ?
		MSK_deleteenv(&env_);
	}
	MSKenv_t     env_;
	MSKrescodee  r_;
};
} // namespace spline

using namespace spline;
OptimizeSpline *OptimizeSpline::instance = 0;


OptimizeSpline::OptimizeSpline()
	: pImpl_(new OptimizePImpl())
{
	// NOTHING		
}

OptimizeSpline::~OptimizeSpline()
{
	// NOTHING		
}

/* This function prints log output from MOSEK to the terminal. */
static void MSKAPI printstr(void *handle,
                            MSKCONST char str[])
{
  printf("%s",str);
} /* printstr */



void ComputeHMatrices(const spline::T_Waypoint& waypoints, 
	spline::MatrixX& h1, spline::MatrixX& h2, spline::MatrixX& h3, spline::MatrixX& h4/*, spline::MatrixX& h5, spline::MatrixX& h6*/)
{
	
	/*first compute the h matrices*/
	size_t size = waypoints.size();
	assert(size > 1);
	
	spline::Real dTi, dTi_1, dTi_sqr, dTi_1sqr, dTi_cube;
	spline::Real t_previous = waypoints[0].first;

	// I think using numbers instead of iterators will be clearer on this case
	for(int i=0; i< size - 1; ++i)
	{
		dTi      = waypoints[i + 1].first - waypoints[i].first;
		dTi_sqr  = dTi * dTi;
		dTi_cube = dTi_sqr * dTi;
		
		assert(dTi > 0); //make sure of the ascendant order

		// filling matrices values
		h3(i,i)   = -3 / dTi_sqr;
		h3(i,i+1) =  3 / dTi_sqr;
				
		h4(i,i)   = -2 / dTi;
		h4(i,i+1) = -1 / dTi;

		/*h5(i,i)   =  2 / dTi_cube;
		h5(i,i+1) = -2 / dTi_cube;
		
		h6(i,i)   = 1 / dTi_sqr;
		h6(i,i+1) = 1 / dTi_sqr;*/

		// we stop one step earlier for matrices h1 and h2
		if(i + 2 < size)
		{
			// this can be optimized but let's focus on clarity as long as not needed
			dTi_1	  = waypoints[i + 2].first - waypoints[i + 1].first;
			dTi_1sqr  = dTi_1 * dTi_1;

			h1(i+1, i)   = 2 / dTi;
			h1(i+1, i+1) = 4 / dTi + 4 / dTi_1;
			h1(i+1, i+2) = 2 / dTi_1;

			h2(i+1, i)   = - 6 / dTi_sqr;
			h2(i+1, i+1) =   (6 / dTi_1sqr) - (6 / dTi_sqr);
			h2(i+1, i+2) =   6 / dTi_1sqr;
		}
	}
	
}

// TODO : compute h entries directly in matrix A

Curve_ABC* OptimizeSpline::GenerateOptimizedCurve(const T_Waypoint& waypoints)

{
	int size = (int)waypoints.size();
	// refer to the paper to understand all this.
	spline::MatrixX h1 = spline::MatrixX::Zero(size, size);
	spline::MatrixX h2 = spline::MatrixX::Zero(size, size);
	spline::MatrixX h3 = spline::MatrixX::Zero(size, size);
	spline::MatrixX h4 = spline::MatrixX::Zero(size, size);

	// remove this for the time being
	/*spline::MatrixX g1 = spline::MatrixX::Zero(size, size);
	spline::MatrixX g2 = spline::MatrixX::Zero(size, size);
	spline::MatrixX g3 = spline::MatrixX::Zero(size, size);
	spline::MatrixX g4 = spline::MatrixX::Zero(size, size);*/

	ComputeHMatrices(waypoints, h1, h2, h3, h4);

	// number of Waypoints : T + 1 => T mid points. 3 variables per points, + acceleration + derivations
	// (T * t+ 1 ) * 3 * 3 = nb var 

// NOG const MSKint32t numvar = ( size + size - 1) * 3 * 3;
	const MSKint32t numvar = (size) * 3 * 3;
	/*
	We store the variables in that order to simplifly matrix computation ( see later )
// NOG [ x0  x1 --- xn y0 --- y z0 --- zn x0. --- zn. x0..--- zn.. x0' --- zn..' ] T
	   [ x0  x1 --- xn y0 --- y z0 --- zn x0. --- zn. x0..--- zn..] T
	*/
	
	/*the first constraint is H1x. = H2x => H2x - H1x. = 0
	this will give us size * 3 inequalities constraints
	So this line of A will be writen
	H2 -H1 0 0 0 0
	*/

	int ptOff     = (int) 3 * size; // . offest
	int ptptOff   = (int) 6 * size; // .. offest
	int prOff     = (int) 3 * ptOff; // ' offest
// NOG int prptOff   = (int) prOff + ptOff; // '. offest
// NOG int prptptOff = (int) prptOff + ptOff; // '.. offest

	spline::MatrixX h2x_h1x = spline::MatrixX::Zero(size * 3, numvar);
	/**A looks something like that : (n = size)
	[H2(0)  0      0     -H1(0) 0-------------------0]
	[ 0  0  H2(0)  0       0   -H1(0)---------------0]
	[ 0  0  0      H2(0)   0     0     H1(0)--------0]
	...
	[ 0  0  0      0   H2(n)   0    0      0     -H1(n)-0] // row n

	Overall it's fairly easy to fill	
	*/
	for(int i = 0; i < size*3; i = i + 3)
	{
		for(int j = 0; j<3; ++j)
		{
			int id = i + j;
			h2x_h1x.block(id, j*size    , 1, size)  = h2.row(i%3);
			h2x_h1x.block(id, j*size + ptOff, 1, size) -= h1.row(i%3);
		}
	}

	
	/*the second constraint is x' = G1x + G2x. => G1x + G2x. - x' = 0
	this will give us size * 3 inequalities constraints
	So this line of A will be writen
	H2 -H1 0 0 0 0
	*/spline::MatrixX g1x_g2x = spline::MatrixX::Zero(size * 3, numvar);
	/**A looks something like that : (n = size)
	[G1(0)  0      0     G2(0) 0-----------------------0 -1 0]
	[ 0  0  G1(0)  0       0   G2(0)-------------------0 -1 0]
	[ 0  0  0      G1(0)   0     0     G2(0)-----------0 -1 0]
	...
	[ 0  0  0      0   G1(n)   0    0      0     G2(n)-0 -1 0] // row n

	Overall it's fairly easy to fill	
	*/
// NOG 
	/*for(int j = 0; j<3; ++j)
	{
		for(int j =0; j<3; ++j)
		{
			int id = i + j;
			g1x_g2x.block(id, j*size	    , 1, size)   = g1.row(i);
			g1x_g2x.block(id, j*size + ptOff, 1, size)   = g2.row(i);
			g1x_g2x.block(id, j*size + prOff, 1, size)  -= spline::MatrixX::Ones(1, size);
		}
	}*/

	/*the third constraint is x.' = G3x + G4x. => G3x + G4x. - x.' = 0
	this will give us size * 3 inequalities constraints
	So this line of A will be writen
	H2 -H1 0 0 0 0
	*/spline::MatrixX g3x_g4x = spline::MatrixX::Zero(size * 3, numvar);
	/**A looks something like that : (n = size)
	[G3(0)  0      0     G4(0) 0-------------------0 -1 0]
	[ 0  0  G3(0)  0       0   G4(0)---------------0 -1 0]
	[ 0  0  0      G3(0)   0     0     G4(0)--------0 -1 0]
	...
	[ 0  0  0      0   G3(n)   0    0      0     G4(n)-0 -1 0] // row n

	Overall it's fairly easy to fill	
	*/
// NOG 
	/*for(int j = 0; j<3; ++j)
	{
		for(int j =0; j<3; ++j)
		{
			int id = i + j;
			g3x_g4x.block(id, j*size		 , 1, size)   = g3.row(i);
			g3x_g4x.block(id, j*size + ptOff, 1, size)   = g4.row(i);
			g3x_g4x.block(id, j*size + prptOff, 1, size)  -= spline::MatrixX::Ones(1, size);
		}
	}
*/
	/*the fourth constraint is x.. = 1/2(H3x + H4x.) => 1/2(H3x + H4x.) - x.. = 0
	=> H3x + H4x. - 2x.. = 0
	this will give us size * 3 inequalities constraints
	So this line of A will be writen
	H2 -H1 0 0 0 0
	*/
	spline::MatrixX h3x_h4x = spline::MatrixX::Zero(size * 3, numvar);
	/**A looks something like that : (n = size)
	[H3(0)  0      0     H4(0) 0-------------------0 -2 0]
	[ 0  0  H3(0)  0       0   H4(0)---------------0 -2 0]
	[ 0  0  0      H3(0)   0     0     H4(0)-------0 -2 0]
	...
	[ 0  0  0      0   H3(n)   0    0      0     H4(n)-0 -2 0] // row n

	Overall it's fairly easy to fill	
	*/
	for(int i = 0; i < size*3; i = i + 3)
	{
		for(int j = 0; j<3; ++j)
		{
			int id = i + j;
			h3x_h4x.block(id, j*size		   , 1, size) = h3.row(i%3);
			h3x_h4x.block(id, j*size + ptOff  , 1, size) = h4.row(i%3);
			h3x_h4x.block(id, j*size + ptptOff, 1, size) = spline::MatrixX::Ones(1, size) * -2;
		}
	}

	/*the following constraints are easy to understand*/

	/*x0,: = x^0*/
	spline::MatrixX x0_x0 = spline::MatrixX::Zero(3, numvar);
	for(int j = 0; j<3; ++j)
	{
		x0_x0(0, 0)		   = 1;
		x0_x0(1, size)	   = 1;
		x0_x0(2, size * 2) = 1;
	}

	/*x0.,: = 0*/
	spline::MatrixX x0p_0 = spline::MatrixX::Zero(3, numvar);
	for(int j = 0; j<3; ++j)
	{
		x0p_0(0, ptOff)	   = 1;
		x0p_0(1, ptOff + size) = 1;
		x0p_0(2, ptOff + size * 2) = 1;
	}
		
	/*xt,: = x^t*/
	spline::MatrixX xt_xt = spline::MatrixX::Zero(3, numvar);
	for(int j = 0; j<3; ++j)
	{
		xt_xt(0, size - 1)	   = 1;
		xt_xt(1, 2 * size - 1) = 1;
		xt_xt(2, 3* size  - 1) = 1;
	}

	/*xT.,: = 0*/
	spline::MatrixX xtp_0 = spline::MatrixX::Zero(3, numvar);
	for(int j = 0; j<3; ++j)
	{
		xtp_0(0, ptOff + size - 1)	         = 1;
		xtp_0(1, ptOff + size + size - 1)    = 1;
		xtp_0(2, ptOff + size * 2 + size - 1)= 1;
	}

	//skipping constraints on x and y accelerations for the time being
	// to compute A i'll create an eigen matrix, then i'll convert it to a sparse one and fill those tables

	//total number of constraints
// NOG h2x_h1x (size * 3) + h3x_h4x (size * 3 ) + g1x_g2x (size * 3 ) + g3x_g4x (size*3) 
// NOG + x0_x0 (3 ) + x0p_0 (3) + xt_xt (3)  + xtp_0 (3) = 12 * size + 12
	// h2x_h1x (size * 3) + h3x_h4x (size * 3 )
	// + x0_x0 (3 ) + x0p_0 (3) + xt_xt (3)  + xtp_0 (3) = 6 * size + 12
// NOG const MSKint32t numcon = 12 * size + 12;
	const MSKint32t numcon =  6 * size + 12; // TODO

	//this gives us the matrix A of size numcon * numvaar
	spline::MatrixX a = spline::MatrixX::Zero(numcon, numvar);
	a.block(0           , 0, size * 3, numvar) = h2x_h1x;
	a.block(size * 3    , 0, size * 3, numvar) = h3x_h4x;
	a.block(size * 6    , 0,        3, numvar) = x0_x0  ;
	a.block(size * 6 + 3, 0,        3, numvar) = x0p_0  ;
	a.block(size * 6 + 6, 0,        3, numvar) = xt_xt  ;
	a.block(size * 6 + 9, 0,        3, numvar) = xtp_0  ;

	//convert to sparse representation
	Eigen::SparseMatrix<Real> spA;
	spA = a.sparseView();
	
	std::cout << "wtf" << std::endl << a << std::endl;

	//convert to sparse representation using column
	// http://docs.mosek.com/7.0/capi/Conventions_employed_in_the_API.html#sec-intro-subsubsec-cmo-rmo-matrix

	int nonZeros = spA.nonZeros();
	
	/* Below is the sparse representation of the A
	matrix stored by column. */
	double*		aval  = new double[nonZeros];
	MSKint32t*  asub  = new MSKint32t[nonZeros];
	MSKint32t*  aptrb = new MSKint32t[numvar];
	MSKint32t*  aptre = new MSKint32t[numvar];

	int currentIndex = 0;
	for(int j=0; j<numvar; ++j)
	{
		bool nonZeroAtThisCol = false;
		for(int i=0; i<numcon; ++i)
		{
			if(a(i,j) != 0)
			{
				if(!nonZeroAtThisCol)
				{
					aptrb[j] = currentIndex;
					nonZeroAtThisCol = true;
				}
				aval[currentIndex] = a(i,j);
				asub[currentIndex] = i;
				aptre[j] = currentIndex + 1; //overriding previous value
				++currentIndex;
			}
		}
	}

	/*Q looks like this
	0 0 0 0 0 0  | -> size * 3
	0 0 2 0 0 0  | -> size *3
	0 0 0 0 0 0
	0 0 0 0 2 0
	0 0 0 0 0 0	
	*/
	/* Number of non-zeros in Q.*/
	const MSKint32t  numqz = size * 3;
	MSKint32t* qsubi = new MSKint32t[numqz]; 
	MSKint32t* qsubj = new MSKint32t[numqz]; 
	double*	   qval  = new double   [numqz];
	for(int id = 0; id < numqz; ++id)
	{
		qsubi[id] = id + ptOff; // we want the x.
		qsubj[id] = id + ptOff;
		 qval[id] = 2;
	}
	
	 /* Bounds on constraints. */
	MSKboundkeye* bkc  = new MSKboundkeye[numcon];
	  
	double*   blc = new double[numcon];
	double*   buc = new double[numcon];

	for(int i = 0; i < numcon; ++i)
	{
		bkc[i] = MSK_BK_FX;
		blc[i] = 0;
		buc[i] = 0;
	}

	///*No Bounds on variables. */
	MSKboundkeye* bkx  = new MSKboundkeye[numvar];
	  
	double*   blx = new double[numvar];
	double*   bux = new double[numvar];

	for(int i = 0; i < numcon; ++i)
	{
		bkx[i] = MSK_BK_FR;
		blx[i] = -MSK_INFINITY;
		bux[i] = +MSK_INFINITY;
	}

	MSKrescodee  r;
	MSKtask_t    task = NULL;
	/* Create the optimization task. */
	r = MSK_maketask(pImpl_->env_,numcon,numvar,&task);

	/* Directs the log task stream to the 'printstr' function. */
	if ( r==MSK_RES_OK )
		r = MSK_linkfunctotaskstream(task,MSK_STREAM_LOG,NULL,printstr);

	/* Append 'numcon' empty constraints.
		The constraints will initially have no bounds. */
	if ( r == MSK_RES_OK )
		r = MSK_appendcons(task,numcon);

	/* Append 'numvar' variables.
		The variables will initially be fixed at zero (x=0). */
	if ( r == MSK_RES_OK )
		r = MSK_appendvars(task,numvar);

	for(int j=0; j<numvar && r == MSK_RES_OK; ++j)
	{
	/* Set the linear term c_j in the objective.*/   
      if(r == MSK_RES_OK) 
        r = MSK_putcj(task,j,0); 

		/* Set the bounds on variable j.
		blx[j] <= x_j <= bux[j] */
		if(r == MSK_RES_OK)
		r = MSK_putvarbound(task,
							j,           /* Index of variable.*/
							bkx[j],      /* Bound key.*/
							blx[j],      /* Numerical value of lower bound.*/
							bux[j]);     /* Numerical value of upper bound.*/

		/* Input column j of A */   
		if(r == MSK_RES_OK)
		r = MSK_putacol(task,
						j,                 /* Variable (column) index.*/
						aptre[j]-aptrb[j], /* Number of non-zeros in column j.*/
						asub+aptrb[j],     /* Pointer to row indexes of column j.*/
						aval+aptrb[j]);    /* Pointer to Values of column j.*/
	}

	/* Set the bounds on constraints.
		for i=1, ...,numcon : blc[i] <= constraint i <= buc[i] */
	for(int i=0; i<numcon && r == MSK_RES_OK; ++i)
		r = MSK_putconbound(task,
							i,           /* Index of constraint.*/
							bkc[i],      /* Bound key.*/
							blc[i],      /* Numerical value of lower bound.*/
							buc[i]);     /* Numerical value of upper bound.*/

	/* Maximize objective function. */
	if (r == MSK_RES_OK)
		r = MSK_putobjsense(task, MSK_OBJECTIVE_SENSE_MINIMIZE);


	if ( r==MSK_RES_OK ) 
      {  
        /* Input the Q for the objective. */ 
 
        r = MSK_putqobj(task,numqz,qsubi,qsubj,qval); 
      } 

	if ( r==MSK_RES_OK )
	{
		MSKrescodee trmcode;
    
		/* Run optimizer */
		r = MSK_optimizetrm(task,&trmcode);

		/* Print a summary containing information
			about the solution for debugging purposes. */
		MSK_solutionsummary (task,MSK_STREAM_LOG);
     
		if ( r==MSK_RES_OK )
		{
		MSKsolstae solsta;
    
		if ( r==MSK_RES_OK )
			r = MSK_getsolsta (task,
								MSK_SOL_BAS,
								&solsta);
		switch(solsta)
		{
			case MSK_SOL_STA_OPTIMAL:   
			case MSK_SOL_STA_NEAR_OPTIMAL:
			{
			double *xx = (double*) calloc(numvar,sizeof(double));
			if ( xx )
			{
				MSK_getxx(task,
						MSK_SOL_BAS,    /* Request the basic solution. */
						xx);
        
				printf("Optimal primal solution\n");
				for(int j=0; j<numvar; ++j)
				printf("x[%d]: %e\n",j,xx[j]);

				free(xx);
			}
			else 
				r = MSK_RES_ERR_SPACE;

			break;
			}
			case MSK_SOL_STA_DUAL_INFEAS_CER:
			case MSK_SOL_STA_PRIM_INFEAS_CER:
			case MSK_SOL_STA_NEAR_DUAL_INFEAS_CER:
			case MSK_SOL_STA_NEAR_PRIM_INFEAS_CER:  
			printf("Primal or dual infeasibility certificate found.\n");
			break;
			case MSK_SOL_STA_UNKNOWN:
			{
			char symname[MSK_MAX_STR_LEN];
			char desc[MSK_MAX_STR_LEN];

			/* If the solutions status is unknown, print the termination code
				indicating why the optimizer terminated prematurely. */
            
			MSK_getcodedesc(trmcode,
							symname,
							desc);
            
			printf("The solutuion status is unknown.\n");
			printf("The optimizer terminitated with code: %s\n",symname);
			break;
			}
			default:
			printf("Other solution status.\n");
			break;
		}
		}
	}
    
	if (r != MSK_RES_OK)
	{
		/* In case of an error print error code and description. */      
		char symname[MSK_MAX_STR_LEN];
		char desc[MSK_MAX_STR_LEN];
      
		printf("An error occurred while optimizing.\n");     
		MSK_getcodedesc (r,
						symname,
						desc);
		printf("Error %s - '%s'\n",symname,desc);
	}
    
	/* Delete the task and the associated data. */
	MSK_deletetask(&task);

	/* Delete the environment and the associated data. */
	//MSK_deleteenv(&env);
    
	//return r;
return 0;
}
