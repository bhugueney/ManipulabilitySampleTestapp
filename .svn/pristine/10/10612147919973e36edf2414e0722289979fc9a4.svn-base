
#ifndef _CLASS_STATE
#define _CLASS_STATE

#include "API/SampleVisitorI.h"
#include "API/PostureManagerI.h"
#include "API/PostureScorerI.h"

#include "kinematic/Robot.h"
#include <algorithm>    // std::sort

#include <vector>

namespace statepostures
{
	struct State
	{
		typedef std::vector<bool> T_State;
		typedef T_State::const_iterator CIT_State;
		typedef std::pair<const State*, int> Transition;
		typedef std::vector<Transition> T_Transition;
		typedef T_Transition::const_iterator CIT_Transition;

		State(const manip_core::T_PostureState& state)
			: lockedTrees_(state)
		{
			// NOTHING
		}
		
		bool Equals(const manip_core::T_PostureState& stateA) const
		{
			assert(stateA.size() == lockedTrees_.size());
			int nbDiff = 0;
			CIT_State it = stateA.begin();
			CIT_State it2 = lockedTrees_.begin();
			for(; it2 != lockedTrees_.end() && nbDiff < 1; ++it, ++it2)
			{
				if((*it) != (*it2))
				{
					++nbDiff;
				}
			}
			return nbDiff == 0;
		}

		bool Equals(const State& stateA) const
		{
			assert(stateA.size() == lockedTrees_.size());
			int nbDiff = 0;
			CIT_State it = stateA.lockedTrees_.begin();
			CIT_State it2 = lockedTrees_.begin();
			for(; it2 != lockedTrees_.end() && nbDiff < 1; ++it, ++it2)
			{
				if((*it) != (*it2))
				{
					++nbDiff;
				}
			}
			return nbDiff == 0;
		}

		bool CanTransit(const State& stateA, int& index) const
		{
			assert(stateA.lockedTrees_.size() == lockedTrees_.size());
			int nbDiff = 0;
			CIT_State it = stateA.lockedTrees_.begin();
			CIT_State it2 = lockedTrees_.begin();
			for(int i = 0; it2 != lockedTrees_.end() && nbDiff < 2; ++i, ++it, ++it2)
			{
				if((*it) != (*it2))
				{
					++nbDiff;
					index = i;
				}
			}
			return nbDiff < 2;
		}

		void AddTransitions(const std::vector<State>& states)
		{
			for(std::vector<State>::const_iterator it = states.begin(); it != states.end(); ++ it)
			{
				int index = -1;
				if(CanTransit(*it, index))
				{
					transitions_.push_back( std::make_pair(&(*it), index));
				}
			}
		}


		manip_core::T_PostureState lockedTrees_;
		T_Transition transitions_;
	};

	struct TransitionSort {
		TransitionSort(const manip_core::PostureScorerI* scorer, State& state)
			: scorer_(scorer)
			, state_(state)
		{
			okCons = 0;
			for(State::CIT_State it = state.lockedTrees_.begin(); it != state.lockedTrees_.end() ; ++it)
			{
				if((*it))
				{
					++okCons;
				}
			}
		}
		
		~TransitionSort()
		{
			// NOTHING
		}

		bool operator() (State::Transition i,State::Transition j)
		{
			float scoreI=(*scorer_)(i.first->lockedTrees_);
			float scoreJ= (*scorer_)(j.first->lockedTrees_);
			return (scoreI > scoreJ) || (i.first->Equals(state_) && scoreI == scoreJ);
		}

		
		void SortTransitions()
		{
			 std::sort(state_.transitions_.begin(), state_.transitions_.end(), *this); 
		};

		const manip_core::PostureScorerI* scorer_;
		State& state_;
		int okCons;
	};


	struct StateTree
	{
		StateTree(const std::vector<manip_core::T_PostureState>& validStates, const manip_core::PostureScorerI* scorer)
		{
			for(std::vector<manip_core::T_PostureState>::const_iterator it = validStates.begin(); it!= validStates.end(); ++it)
			{
				states.push_back(State (*it));
			}
			for(std::vector<State>::iterator it = states.begin(); it!= states.end(); ++it)
			{
				(*it).AddTransitions(states);
			}
			for(std::vector<State>::iterator it = states.begin(); it!= states.end(); ++it)
			{
				TransitionSort sort(scorer, *it);
				sort.SortTransitions();
			}
		}

		const State& GetState(const Robot& robot)
		{
			assert(states.size() > 0 && robot.GetNumTrees() == states[0].lockedTrees_.size());
			manip_core::T_PostureState state;
			for(Robot::T_TreeCIT it = robot.GetTrees().begin(); it != robot.GetTrees().end(); ++it)
			{
				state.push_back((*it)->IsLocked());
			}
			for(std::vector<State>::iterator it = states.begin(); it!= states.end(); ++it)
			{
				if((*it).Equals(state))
				{
					return (*it);
				}
			}
			throw; // NOT FOUND, probably all false -> make all transitions;
		}

		bool IsInValidState(const Robot& robot)
		{
			assert(states.size() > 0 && robot.GetNumTrees() == states[0].lockedTrees_.size());
			manip_core::T_PostureState state;
			for(Robot::T_TreeCIT it = robot.GetTrees().begin(); it != robot.GetTrees().end(); ++it)
			{
				state.push_back((*it)->IsLocked());
			}
			for(std::vector<State>::iterator it = states.begin(); it!= states.end(); ++it)
			{
				if((*it).Equals(state))
				{
					return true;
				}
			}
			return false; // TODO
		}

		
		void FreeRessources(std::vector<manip_core::RobotI*> toFree) const
		{
			for(std::vector<manip_core::RobotI*>::iterator it = toFree.begin(); it != toFree.end(); ++it)
			{
				(*it)->Release();
			}
			toFree.clear();
		}

		std::vector<State> states;
	};
}
#endif //_CLASS_STATE