#include "SimpleSampleVisitor.h"

#include "kinematic/SampleGenerator.h"
#include "kinematic/Sample.h"
#include "kinematic/Tree.h"

using namespace matrices;

struct PImpl
{
	PImpl()
		: sample_(0)
		, forceCoeff_(0)
		, velocCoeff_(0)
		, currentOutput_(0)
		, currentDirection_(0, 0, 0)
	{
		//NOTHING
	}
	~PImpl()
	{
		//NOTHING
	}

	void Reset()
	{
		sample_ = 0;
		currentOutput_ = 0;
		currentDirection_ = Vector3::Zero();
	}

	float forceCoeff_;
	float velocCoeff_;
	Sample* sample_;
	float currentOutput_;
	Vector3 currentDirection_;
};

SimpleSampleVisitor::SimpleSampleVisitor()
	: SampleGeneratorVisitor_ABC()
	, pImpl_(new PImpl())
{
	//NOTHING
}

SimpleSampleVisitor::~SimpleSampleVisitor()
{
	// NOTHING
}

void SimpleSampleVisitor::Visit(Sample& sample)
{
	float value = 0.f; float tmp = 0.f;
	if(pImpl_->forceCoeff_ != 0)
	{
		tmp = sample.forceManipulabiliy(pImpl_->currentDirection_);
		if (tmp <0) tmp = 0;
		value += pImpl_->forceCoeff_ * tmp;
	}
	if(pImpl_->velocCoeff_ != 0)
	{
		tmp = sample.velocityManipulabiliy(pImpl_->currentDirection_);
		if (tmp <0) tmp = 0;
		value += pImpl_->velocCoeff_ * tmp;
	}
	if(value > pImpl_->currentOutput_)
	{
		pImpl_->currentOutput_ = value;
		pImpl_->sample_ = &sample;
	}
}

void SimpleSampleVisitor::Configure(float force, float velocity)
{
	pImpl_->forceCoeff_ = force;
	pImpl_->velocCoeff_ = velocity;
}

#include <iostream>

Sample* SimpleSampleVisitor::Run(const SampleGenerator& generator, const matrices::Vector3& direction)
{
	pImpl_->Reset();
	pImpl_->currentDirection_ = direction;
	generator.Accept(*this);
	return pImpl_->sample_;
}
