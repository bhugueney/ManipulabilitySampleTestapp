#include "WorldParserObj.h"

#include "Simulation.h"

#include "MatrixDefs.h"

#include <iostream>
#include <fstream>
#include <string>
#include <stdlib.h>

using namespace matrices;
using namespace std;

WorldParserObj::WorldParserObj()
	:manager_(Simulation::GetInstance()->manager_)
{
	// NOTHING
}

WorldParserObj::~WorldParserObj()
{
	// NOTHING
}

void WorldParserObj::CreateWorld(const std::string& filename)
{
	string line;
	ifstream myfile (filename);
	std::vector<std::string> lines;
	if (myfile.is_open())
	{
		while ( myfile.good() )
		{
			getline (myfile,line);
			if(line.find("v ") == 0)
			{
				lines.push_back(line);
				if(lines.size() == 4)
				{
					CreateObstacle(lines);
					lines.clear();
				}
				cout << line << endl;
			}
		}
		myfile.close();
	}
}


namespace
{
	typedef std::vector<matrices::Vector3,Eigen::aligned_allocator<matrices::Vector3>> T_Point;

	NUMBER isLeft( const VectorX& P0, const VectorX& P1, const Vector3& P2 )
	{
		return ( (P1.x() - P0.x()) * (P2.y() - P0.y())
				- (P2.x() - P0.x()) * (P1.y() - P0.y()) );
	}

	const Vector3& LeftMost(const T_Point& points)
	{
		unsigned int i = 0;
		for(unsigned int j = 1; j < points.size(); ++j)
		{
			if(points[j].x() < points[i].x())
			{
				i = j;
			}
		}
		return points[i];
	}

	T_Point ConvexHull(const T_Point& points)
	{
		T_Point res;
		Vector3 pointOnHull = LeftMost(points);	
		Vector3 endPoint;
		int i = 0;
		do
		{
			++i;
			VectorX pi = pointOnHull;
			endPoint = points[0];
			for(unsigned int j = 1; j < points.size(); ++j)
			{
				if((endPoint == pointOnHull) || (isLeft(pi, endPoint, points[j]) > 0))
				{
					endPoint = points[j];
				}
				
				if( i > 10000 )
				{
					std::cout << " WTF " << std::endl << points[j] << std::endl;
					bool gtd = false;
				}
			}
			res.push_back(pi);
			pointOnHull = endPoint;
		} while(endPoint != res[0]);
		res.push_back(endPoint);
		return res;
	}
}

using namespace matrices;

void WorldParserObj::CreateObstacle(const std::vector<std::string>& lines)
{
	T_Point points;
	for(int i =0; i<4; ++i)
	{
		char x[255],y[255],z[255];
		sscanf(lines[i].c_str(),"v %s %s %s",x,z,y);
		points.push_back(Vector3(-strtod (x, NULL), strtod(y, NULL), strtod(z, NULL)));
	}

	Vector3 p1(points[0]);
	Vector3 p2(points[1]);
	Vector3 p3(points[2]);
	Vector3 p4(points[3]);
	Vector3 u_(p3-p4);
	Vector3 v_(p1-p4);
	double a_, b_, c_, d_, norm_, normsquare_;
	//we need convex hull of this crap
	Vector3 normal (u_.cross(v_));
	a_ = (float)(normal.x());
	b_ = (float)(normal.y());
	c_ = (float)(normal.z());
	//if (c_ < 0) c_ = -c_;
	norm_ = (float)(normal.norm());
	normsquare_ = norm_ * norm_;
	d_ = (float)(-(a_ * p1.x() + b_ * p1.y() + c_ * p1.z()));

	Matrix4 basis_ = Matrix4::Zero();
	Vector3 x = (p3 - p4); x.normalize();
	Vector3 y = (p1 - p4); y.normalize();
	normal.normalize();
	basis_.block(0,0,3,1) = x;
	basis_.block(0,1,3,1) = y;
	basis_.block(0,2,3,1) = normal;
	basis_.block(0,3,3,1) = p4;
	basis_(3,3) = 1;
	Matrix4 basisInverse_ = basis_.inverse();

	T_Point transformedPoints;
	for(int i=0; i<4; ++i)
	{
		transformedPoints.push_back(matrices::matrix4TimesVect3(basisInverse_, points[i]));
	}

	points = ConvexHull(transformedPoints);
	transformedPoints.clear();
	for(int i=0; i<4; ++i)
	{
		transformedPoints.push_back(matrices::matrix4TimesVect3(basis_, points[i]));
	}

	manager_.AddObstacle(transformedPoints[0], transformedPoints[1], transformedPoints[2], transformedPoints[3]);
}
