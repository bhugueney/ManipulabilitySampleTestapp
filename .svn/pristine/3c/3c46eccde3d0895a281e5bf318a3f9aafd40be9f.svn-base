#include "MotionHandler.h"
#include "Simulation.h"

#include "IKSolver/IKSolver.h"

#include "Draw/DrawSpline.h"

#include "API/TreeI.h"
#include "API/RobotI.h"

class MotionActionTranslation : public MotionAction_ABC
{
public:
	MotionActionTranslation(NUMBER speed, const matrices::Vector3& direction) 
		: MotionAction_ABC()
		, direction_(direction)
		, speed_(speed)
	{
		if(direction_.norm() > 0)
		{
			direction_.normalize();
		}
	}

	~MotionActionTranslation()
	{
		// NOTHING
	}

	virtual void operator() (manip_core::RobotI& robot, const Timer::t_time dt)
	{
		double tab [3];
		matrices::vect3ToArray(tab, direction_* dt * speed_);
		robot.Translate(tab);
	}

	matrices::Vector3 direction_;
	NUMBER speed_;
};

class MotionActionRotation : public MotionAction_ABC
{
public:
	MotionActionRotation(NUMBER speed, const matrices::Matrix3& rotation) 
		: MotionAction_ABC()
		, rotation_(rotation)
		, speed_(speed)
	{
		// NOTHING
	}

	~MotionActionRotation()
	{
		// NOTHING
	}

	virtual void operator() (manip_core::RobotI& robot, const Timer::t_time dt)
	{
		matrices::Matrix4 transform;
		double transf[16];
		robot.ToWorldCoordinates(transf);
		matrices::array16ToMatrix4(transf, transform);
		transform.block<3,3>(0,0) = transform.block<3,3>(0,0) * rotation_;
		matrices::matrixTo16Array(transf, transform);
		robot.SetTransform(transf);
	}

	matrices::Matrix3 rotation_;
	NUMBER speed_;
};

MotionHandler::MotionHandler(manip_core::ManipManager& manager, const float rotationSpeed, const float translationSpeed)
	: rotationSpeed_(rotationSpeed)
	, translationSpeed_(translationSpeed)
	, solver_(manager.GetIkSolver())
	, postureManager_(manager.GetPostureManager())
	, previousDirection_(1,0,0)
{
	// NOTHING
}

MotionHandler::~MotionHandler()
{
	// NOTHING
}

void MotionHandler::Update(const Timer::t_time t, const Timer::t_time dt)
{
	// insert actions
	Simulation* sg = Simulation::GetInstance();
	manip_core::RobotI* robot = sg->pRobot;
	
	matrices::Matrix4 transform;
	double transf[16];
	robot->ToRobotCoordinates(transf);
	matrices::array16ToMatrix4(transf, transform);

	bool findPosture =  !(actions_.empty)(); // don't call NexPosture if I did not move
	while(!actions_.empty())
	{
		(actions_.front())->operator()(*robot, dt);
		delete actions_.front();
		actions_.pop();
	}

	//now let's get more serious
	if(findPosture)
	{
		manip_core::T_CubicTrajectory cubics = postureManager_->NextPosture(robot, previousDirection_);
		// replace previous splines
		for(manip_core::IT_CubicTrajectory it = cubics.begin(); it!= cubics.end(); ++it)
		{
			IT_SplineManager it2 = splineManagers_.find(it->first);
			if( it2 != splineManagers_.end())
			{
				delete(it2->second);
				splineManagers_.erase(it2);
			}
			splineManagers_.insert(std::make_pair((it->first), new spline::SplineTimeManager(t, it->second)));
		}
	}
	double targ[3];
	for(IT_SplineManager itSpline = splineManagers_.begin(); itSpline!= splineManagers_.end(); ++itSpline)
	{
		//perform ik
		itSpline->second->Update(t,dt);
		matrices::Vector3 target = matrices::matrix4TimesVect3(transform, itSpline->second->GetTarget());
		manip_core::TreeI* t = robot->GetTreeI(itSpline->first);
		matrices::vect3ToArray(targ, itSpline->second->GetTarget());
		t->SetTarget(targ);
		manip_core::TreeI * tree = robot->GetTreeI(itSpline->first);
		if (tree->IsAnchored())
		solver_.StepClamping(robot, robot->GetTreeI(itSpline->first), target, previousDirection_);
		if(sg->simpParams_.drawNormals_)
		{
			DrawSpline ds(itSpline->second->GetCubic());
			ds.Draw();
		}
	}
}

void MotionHandler::Reset()
{
	previousDirection_ = matrices::Vector3(1,0,0);
	while(!actions_.empty())
	{
		delete actions_.front();
		actions_.pop();
	}
	splineManagers_.clear();
}

void MotionHandler::PushAction(MotionAction_ABC* action)
{
	actions_.push(action);
}

void MotionHandler::Translate(const matrices::Vector3& direction)
{
	Simulation* sg = Simulation::GetInstance();
	previousDirection_ = direction;
	/*update with robot data*/
	if(sg->simpParams_.reachCom_)
	{
		double comDir[2];
		manip_core::RobotI* robot = sg->pRobot;

		robot->ComTarget(comDir);
		if(previousDirection_.x() == 0)
		{
			previousDirection_(0) = comDir[0];
		}
		if(direction.y() == 0)
		{
			previousDirection_(1) = comDir[1];
		}
		previousDirection_.normalize();
	}
	PushAction(new MotionActionTranslation(translationSpeed_, previousDirection_));
	/*Experimental shit*/
	/*matrices::Vector3 dir(comDir[0], comDir[1], 0);
	if(dir.norm() != 0)
	{
		dir.normalize();
		matrices::Vector3 x(1,0,0);
		matrices::Matrix3 result;
		matrices::GetRotationMatrix(x, dir, result);
		Rotate(result);
	}*/
}

void MotionHandler::Rotate(const matrices::Matrix3& rotation)
{
	PushAction(new MotionActionRotation(rotationSpeed_, rotation));
}
