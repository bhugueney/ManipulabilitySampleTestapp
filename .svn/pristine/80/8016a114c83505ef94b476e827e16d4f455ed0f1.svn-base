
#ifndef _CLASS_OBSTACLE
#define _CLASS_OBSTACLE

#include "kinematic/MatrixDefs.h"

#include <vector>


class Obstacle {

friend class Intersection;
friend class DrawObstacle;

public:
	typedef std::vector<Obstacle> T_Obstacle;

public:
	//make it clockwise from upper left
	 Obstacle(const matrices::Vector3& /*p1*/, const matrices::Vector3& /*p2*/, const matrices::Vector3& /*p3*/, const matrices::Vector3& /*p4*/ );
	~Obstacle();

public:
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	// Minimal distance between the plan described by the obstacle and a point, that is, the distance btw point and its orthonormal projection on the plan
	float Distance(const matrices::Vector3& /*point*/, matrices::Vector3& /*getCoordinates*/) const; // get coordinates of the projection
	//bool  ContainsPlanar(const matrices::Vector3& /*point*/) const; // point in the plan expressed in local coordinates	

	const matrices::Vector3& Center() const { return center_; }
	const Eigen::Matrix4d& Basis   () const { return basis_; }
	const Eigen::Matrix4d& BasisInv() const { return basisInverse_; }

	float GetD() const { return d_; }
	float GetW() const { return w_; }
	float GetH() const { return h_; }

private:
	const matrices::Vector3 p1_;
	const matrices::Vector3 p2_;
	const matrices::Vector3 p3_;
	const matrices::Vector3 p4_;
		  matrices::Vector3 center_;

	Eigen::Matrix4d basis_; // transformation matrix to rectangle basis ( on p4 )
	Eigen::Matrix4d basisInverse_; // transformation matrix to rectangle basis ( on p4 )

	float a_;
	float b_;
	float c_;
	float d_;
	float norm_;
	float normsquare_;
	float w_;
	float h_;
};

#endif //_CLASS_OBSTACLE