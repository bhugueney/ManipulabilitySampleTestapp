
#include <Eigen/Dense>
#include <Eigen/SVD>

#include <iostream>

#ifndef _MATRIXDEFS
#define _MATRIXDEFS

namespace matrices
{

	typedef Eigen::Vector3d Vector3;
	typedef Eigen::Vector2d Vector2;
	typedef Eigen::VectorXd VectorX;
	typedef Eigen::MatrixXd MatrixX;
	typedef Eigen::Matrix4d Matrix4;

	/* Rotates rotated around axis by angle theta, and returns it */
	static Eigen::Matrix4d Translate(double x, double y, double z)
	{								
		Eigen::Matrix4d mat = Eigen::Matrix4d::Zero();				
		mat(3,0) = x;
		mat(3,1) = y;
		mat(3,2) = z;
		mat(3,3) = 1;
		return mat;
	}
	static Eigen::Matrix4d Translate(Eigen::Vector3d vector)
	{								
		Eigen::Matrix4d mat = Eigen::Matrix4d::Zero();				
		mat(0,3) = vector(0);
		mat(1,3) = vector(1);
		mat(2,3) = vector(2);
		mat(3,3) = 1;
		return mat;
	}
	static Eigen::Matrix4d Rotx4(double theta)
	{
		double c = cos(theta);								
		double s = sin(theta);								
		Eigen::Matrix4d mat = Eigen::Matrix4d::Zero();				
		mat(0,0) = 1;					//	1 	0	0
		mat(1, 1) = c; mat(1, 2) = -s;	//	0	cos -sin
		mat(2, 1) = s; mat(2, 2) = c;	//	0	sin	cos	
		return mat;
	}
	static Eigen::Matrix4d Roty4(double theta)
	{
		double c = cos(theta);										
		double s = sin(theta);										
		Eigen::Matrix4d mat = Eigen::Matrix4d::Zero();		
		mat(0,0) = c; mat(0,2) = s;		//	cos	 0	sin
		mat(1, 1) = 1;					//	0	 1	0
		mat(2,0) = -s; mat(2, 2) = c;	//	-sin 0	cos
		return mat;
	}
	static Eigen::Matrix4d Rotz4(double theta)
	{
		double c = cos(theta);										
		double s = sin(theta);										
		Eigen::Matrix4d mat = Eigen::Matrix4d::Zero();		
		mat(0,0) = c; mat(0,1) = -s ;	//	cos	-sin 0
		mat(1, 0) = s; mat(1, 1) = c;	//	sin	cos	 0
		mat(2, 2) = 1;					//	0	0	 1
		return mat;
	}

	static Eigen::Matrix3d Rotx3(double theta)
	{
		double c = cos(theta);								
		double s = sin(theta);								
		Eigen::Matrix3d mat = Eigen::Matrix3d::Zero();				
		mat(0,0) = 1;					//	1 	0	0
		mat(1,1) = c; mat(1, 2) = -s;	//	0	cos -sin
		mat(2, 1) = s; mat(2, 2) = c;	//	0	sin	cos	
		return mat;
	}
	static Eigen::Matrix3d Roty3(double theta)
	{
		double c = cos(theta);										
		double s = sin(theta);										
		Eigen::Matrix3d mat = Eigen::Matrix3d::Zero();		
		mat(0,0) = c; mat(0,2) = s;		//	cos	 0	sin
		mat(1, 1) = 1;					//	0	 1	0
		mat(2,0) = -s; mat(2, 2) = c;	//	-sin 0	cos
		return mat;
	}
	static Eigen::Matrix3d Rotz3(double theta)
	{
		double c = cos(theta);										
		double s = sin(theta);										
		Eigen::Matrix3d mat = Eigen::Matrix3d::Zero();		
		mat(0,0) = c; mat(0,1) = -s ;	//	cos	-sin 0
		mat(1, 0) = s; mat(1, 1) = c;	//	sin	cos	 0
		mat(2, 2) = 1;					//	0	0	 1
		return mat;
	}

	// TODO forward dec
	static Vector3& Rotate(const Vector3& axis, Vector3& rotated, double theta)
	{
		double x  = rotated.x(); double y  = rotated.y(); double z = rotated.z();
		double x1 = axis.x(); double y1 = axis.y(); double z1 = axis.z();

		double c = cos(theta);
		double s = sin(theta);
		double dotw = (x*x1 + y*y1 + z*z1);
		double v0x = dotw*x1;
		double v0y = dotw*y1;		// v0 = provjection onto axis
		double v0z = dotw*z1;
		double v1x = x-v0x;
		double v1y = y-v0y;			// v1 = projection onto plane normal to axis
		double v1z = z-v0z;
		double v2x = y1*v1z - z1*v1y;
		double v2y = z1*v1x - x1*v1z;	// v2 = axis * v1 (cross product)
		double v2z = x1*v1y - y1*v1x;
		
		rotated(0) = v0x + c*v1x + s*v2x;
		rotated(1) = v0y + c*v1y + s*v2y;
		rotated(2) = v0z	+ c*v1z + s*v2z;
		return rotated;
	}


static void vect4ToVect3(const VectorX& from, Vector3& to )
{
	to = from.block(0,0,3,1);
}

static void vect3ToVect4(const Vector3& from, VectorX& to )
{
	to.block(0,0,3,1) = from;
	to(3) = 1;
}

static Vector3 matrix4TimesVect3(const Matrix4& mat4, const Vector3& vect3 )
{
	VectorX vect4(4);
	Vector3 res;
	vect3ToVect4(vect3, vect4);
	vect4 = mat4 * vect4;
	vect4ToVect3(vect4, res);
	return res;
}

static Vector3 matrix4TimesVect4(const Matrix4& mat4, const VectorX& vect4 )
{
	Vector3 vect3; VectorX res(4);
	res = mat4 * vect4;
	vect4ToVect3(res, vect3);
	return vect3;
}

static void matrixToArray( float * tab, const Eigen::Matrix4d& mat4 )
{
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			tab[ 4*i + j ] = (float)mat4(i,j);
		}
	}
}

static void matrixID( float * tab )
{
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			tab[ 4*i + j ] = i == j ? 1.f : 0.f;
		}
	}
}


static void matrixTo16Array( float * tab, const Eigen::Matrix4d& mat4 )
{
	for( int i =0; i< 4; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			tab[ 4*i + j ] = (float)mat4(i,j);
		}
	}
}

static void vect4ToArray( float * tab, const Eigen::Vector4d& vect )
{
	for( int i =0; i< 3; ++i )
	{
		tab[i] = (float)vect(i);
	}
}

static void vect3ToArray( float * tab, const Eigen::Vector3d& vect )
{
	for( int i =0; i< 3; ++i )
	{
		tab[i] = (float)vect(i);
	}
}

} //namespace matrices

	/*template<typename _Matrix_Type_>
	static void PseudoInverse(_Matrix_Type_& from, _Matrix_Type_& to)
	{
		Eigen::JacobiSVD<_Matrix_Type_> svd(from, Eigen::ComputeFullU | Eigen::ComputeFullU);
		svd.pinv(to);
	}*/


	//REF: boulic et al An inverse kinematics architecture enforcing an arbitrary number of strict priority levels
	template<typename _Matrix_Type_>
	static void PseudoInverseDLS(_Matrix_Type_& pinvmat,  float lambda)
	{
		Eigen::JacobiSVD<_Matrix_Type_> svd(pinvmat, Eigen::ComputeFullU | Eigen::ComputeFullV);
		Eigen::VectorXd m_sigma = svd.singularValues();

// temp computation foireuse pour lambda
// REF: must apply numerical filtering for the operation of robotic manipulators through kinematically singular ...
bool found = false; int i = m_sigma.rows() -1;
double val = 0;
while (!found && i >= 0)
{
	val = m_sigma(i);
	found = m_sigma(i) > 0;
	if (found) lambda = val;
	i--;
}
//end tmp

		double  pinvtoler= lambda != 0 ? 0 : 1.e-6; // choose your tolerance widely!
		float lambda2 = lambda * lambda;

		Eigen::MatrixXd m_sigma_inv = Eigen::MatrixXd::Zero(pinvmat.cols(),pinvmat.rows());
		for ( long i=0; i<m_sigma.rows(); ++i)
		{
			if ( m_sigma(i) > pinvtoler )
				m_sigma_inv(i,i)=m_sigma(i)/( m_sigma(i) * m_sigma(i) + lambda2 );
		}
		pinvmat = (svd.matrixV()*m_sigma_inv*svd.matrixU().transpose());
	}

	template<typename _Matrix_Type_>
	static void PseudoInverseSVDDLS(_Matrix_Type_& pinvmat, Eigen::JacobiSVD<_Matrix_Type_>& svd, _Matrix_Type_& dest, float lambda = 0.f)
	{
	Eigen::VectorXd m_sigma = svd.singularValues();
		
// temp computation foireuse pour lambda
// REF: must apply numerical filtering for the operation of robotic manipulators through kinematically singular ...
bool found = false; int i = m_sigma.rows() -1;
double val = 0;
while (!found && i >= 0)
{
	val = m_sigma(i);
	found = m_sigma(i) > 0;
	if (found) lambda = val;
	i--;
}
//end tmp
		double  pinvtoler= lambda != 0 ? 0 : 1.e-6; // choose your tolerance widely!
		float lambda2 = lambda * lambda;
		
		Eigen::MatrixXd m_sigma_inv = Eigen::MatrixXd::Zero(pinvmat.cols(),pinvmat.rows());
		for ( long i=0; i<m_sigma.rows(); ++i)
		{
			if ( m_sigma(i) > pinvtoler )
				m_sigma_inv(i,i)=m_sigma(i)/( m_sigma(i) * m_sigma(i) + lambda2 );
				//m_sigma_inv(i,i)=1.0/m_sigma(i);
		}
		dest= (svd.matrixV()*m_sigma_inv*svd.matrixU().transpose());
	}

//REF: boulic et al An inverse kinematics architecture enforcing an arbitrary number of strict priority levels
template<typename _Matrix_Type_>
static void PseudoInverse(_Matrix_Type_& pinvmat)
{
	Eigen::JacobiSVD<_Matrix_Type_> svd(pinvmat, Eigen::ComputeFullU | Eigen::ComputeFullV);
	Eigen::VectorXd m_sigma = svd.singularValues();

	double  pinvtoler= 1.e-6; // choose your tolerance widely!

	Eigen::MatrixXd m_sigma_inv = Eigen::MatrixXd::Zero(pinvmat.cols(),pinvmat.rows());
	for ( long i=0; i<m_sigma.rows(); ++i)
	{
		if ( m_sigma(i) > pinvtoler )
			m_sigma_inv(i,i)=1.0/m_sigma(i);
	}
	pinvmat = (svd.matrixV()*m_sigma_inv*svd.matrixU().transpose());
}


#endif //_MATRIXDEFS
