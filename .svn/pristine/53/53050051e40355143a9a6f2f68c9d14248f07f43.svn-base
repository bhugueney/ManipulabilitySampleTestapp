#include "RootTrajectory.h"
#include "Simulation.h"
#include "Draw/DrawSpline.h"

using namespace matrices;

namespace
{
	
	typedef std::vector<matrices::Vector3,Eigen::aligned_allocator<matrices::Vector3>> T_Vector3;
	typedef T_Vector3::const_iterator CIT_Vector3;
}

RootTrajectory::RootTrajectory(curve_abc_t* spline, const matrices::Vector3& initDir)
	: spline_(spline)
	, initDir_(initDir)
	, previous_(initDir)
{
	// NOTHING
}

RootTrajectory::~RootTrajectory()
{
	delete spline_;
	// NOTHING
}

void RootTrajectory::Reset()
{
	previous_ = initDir_;
}

namespace
{
	void Rotate(const matrices::Matrix3& rotation, manip_core::RobotI* robot)
	{
		Simulation* sg = Simulation::GetInstance();
		matrices::Matrix4 transform;
		double transf[16];
		robot->ToWorldCoordinates(transf);
		matrices::array16ToMatrix4(transf, transform);
		transform.block<3,3>(0,0) = transform.block<3,3>(0,0) * rotation;
		matrices::matrixTo16Array(transf, transform);
		robot->SetTransform(transf);
	}
}

void RootTrajectory::ComputeOneUpdate(manip_core::RobotI* robot, const Timer::t_time t, const Timer::t_time dt)
{
	Simulation* sg = Simulation::GetInstance();
	int nbPoses(0);
	for(unsigned int i = 0; i < robot->GetNumTrees(); ++i)
	{
		if(robot->GetTreeI(i)->IsAnchored())
		{
			++nbPoses;
		}
	}
	Vector3 currentPos((*spline_)(std::min(t * sg->simpParams_.speed_, spline_->max())));
	double transf[16];
	robot->ToWorldCoordinates(transf);
	//std::cout << "position  " << transf[3] << "  " << transf[7]  << "  " <<  transf[11] << std::endl;
	//std::cout << "current position  " << currentPos << std::endl;
	currentPos = currentPos - Vector3(transf[3], transf[7], transf[11]);
// TRANSLATION
//sg->motionHandler_.MoveBy(currentPos);
	double tab [3];
	matrices::vect3ToArray(tab, currentPos);
	robot->Translate(tab);
	// ok now compute rotation
	if(currentPos.norm() > 0.0001 && sg->simpParams_.rotatewithspline_ )
	{
		currentPos.normalize();
		matrices::Matrix3 rotation;
		//matrices::GetRotationMatrix(currentPos, previous_, rotation);
		matrices::GetRotationMatrix(previous_, currentPos , rotation);
		//std::cout << "Rotation matrix  " << std::endl << rotation << std::endl;
		previous_ = currentPos;
//sg->motionHandler_.Rotate(rotation);
		Rotate(rotation, robot);
	}
	else if(currentPos.norm() > 0.0001 && sg->simpParams_.rotatewithsplinedir_)
	{
		currentPos.normalize();
		matrices::Matrix3 rotation;
		matrices::GetRotationMatrix(currentPos, previous_, rotation);
		//matrices::GetRotationMatrix(previous_, currentPos , rotation);
		//std::cout << "Rotation matrix  " << std::endl << rotation << std::endl;
		previous_ = currentPos;
//sg->motionHandler_.Rotate(rotation);
		Rotate(rotation, robot);
	}
	// let's try com rotation
		
	if(sg->simpParams_.humanrotate_)
	{
		double comDir[3];
		robot->ComputeCom(comDir);
		matrices::arrayToVect3(comDir, currentPos);
		if(currentPos.norm() > 0.01 && nbPoses > 0)
		{
			currentPos.normalize();
			matrices::Matrix3 rotation;
			//matrices::GetRotationMatrix(currentPos, previous_, rotation);
			matrices::GetRotationMatrix(previous_, currentPos , rotation);
			previous_ = currentPos;
//sg->motionHandler_.Rotate(rotation);
			Rotate(rotation, robot);
		}
	}
}


void RootTrajectory::Update(const Timer::t_time t, const Timer::t_time dt)
{
	Simulation* sg = Simulation::GetInstance();
	if(sg->simpParams_.rootTrajectory_)
	{
		manip_core::RobotI* robot = sg->pRobot;
		Simulation* sg = Simulation::GetInstance();
		int nbPoses(0);
		for(unsigned int i = 0; i < robot->GetNumTrees(); ++i)
		{
			if(robot->GetTreeI(i)->IsAnchored())
			{
				++nbPoses;
			}
		}
		Vector3 currentPos((*spline_)(std::min(t * sg->simpParams_.speed_, spline_->max())));
		double transf[16];
		robot->ToWorldCoordinates(transf);
		//std::cout << "position  " << transf[3] << "  " << transf[7]  << "  " <<  transf[11] << std::endl;
		//std::cout << "current position  " << currentPos << std::endl;
		currentPos = currentPos - Vector3(transf[3], transf[7], transf[11]);
		sg->motionHandler_.MoveBy(currentPos);
		// ok now compute rotation
		if(currentPos.norm() > 0.0001 && sg->simpParams_.rotatewithspline_ )
		{
			currentPos.normalize();
			matrices::Matrix3 rotation;
			//matrices::GetRotationMatrix(currentPos, previous_, rotation);
			matrices::GetRotationMatrix(previous_, currentPos , rotation);
			//std::cout << "Rotation matrix  " << std::endl << rotation << std::endl;
			previous_ = currentPos;
			sg->motionHandler_.Rotate(rotation);
		}
		else if(currentPos.norm() > 0.0001 && sg->simpParams_.rotatewithsplinedir_)
		{
			currentPos.normalize();
			matrices::Matrix3 rotation;
			matrices::GetRotationMatrix(currentPos, previous_, rotation);
			//matrices::GetRotationMatrix(previous_, currentPos , rotation);
			//std::cout << "Rotation matrix  " << std::endl << rotation << std::endl;
			previous_ = currentPos;
			sg->motionHandler_.Rotate(rotation);
		}
		// let's try com rotation
		
		if(sg->simpParams_.humanrotate_)
		{
			double comDir[3];
			robot->ComputeCom(comDir);
			matrices::arrayToVect3(comDir, currentPos);
			if(currentPos.norm() > 0.01 && nbPoses > 0)
			{
				currentPos.normalize();
				matrices::Matrix3 rotation;
				//matrices::GetRotationMatrix(currentPos, previous_, rotation);
				matrices::GetRotationMatrix(previous_, currentPos , rotation);
				previous_ = currentPos;
				sg->motionHandler_.Rotate(rotation);
			}
		}
	}
}

std::vector<manip_core::RobotI*> RootTrajectory::ComputeUpdates(const Timer::t_time start, const Timer::t_time end, const Timer::t_time dt)
{
	std::vector<manip_core::RobotI*> res;
	Simulation* sg = Simulation::GetInstance();
	manip_core::RobotI* r = sg->pRobot->Copy();
	Timer::t_time t = start;
	while(t <= end)
	{
		ComputeOneUpdate(r, t, dt);
		res.push_back(r);
		r = r->Copy();
		t+= dt;
	}
	return res;
}
