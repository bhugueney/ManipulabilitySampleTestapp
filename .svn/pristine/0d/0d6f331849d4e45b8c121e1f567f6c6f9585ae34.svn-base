#include "kinematic/Tree.h"
#include "kinematic/MatrixDefs.h"

#include "kinematic/Pi.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;


#include <iostream>

using namespace std;

#define RADIAN(X)	((X)*RadiansToDegrees)

using namespace matrices;
using namespace Eigen;

Tree* test; // TO F... REMOVE


void command(int cmd)   /**  key control function; */
{
	Joint* joint( 0 );
    switch (cmd)
    {
    case 'a':
        joint = test->GetJoint(1); // increases THETA[1] when a key is pressed
        break;
    case 'z':
        joint = test->GetJoint(2);
        break;
    case 'e':
        joint = test->GetJoint(3);
        break;
    case 'r':
        joint = test->GetJoint(4);
        break;
    case 't':
        joint = test->GetJoint(5);
        break;
    }
	if (joint)
	{
		joint->AddToTheta(0.05);
	}
}

void BuildTree(Joint *node[], Tree &tree)
{
	const Vector3 unitx(1, 0, 0);
	const Vector3 unity(0, 1, 0);
	const Vector3 unitz(0, 0, 1);
	const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
	const Vector3 zero(0,0,0);

	////node[0] = new Joint(Vector3(0.0f, -0.5f, 0.0f), unit1,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	//node[0] = new Joint(Vector3(0.0, -0.5, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	//tree.InsertRoot(node[0]);

	//node[1] = new Joint(Vector3(0.0, -0.5, 0.0), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	//tree.InsertChild(node[0], node[1]);

	//node[2] = new Joint(Vector3(0.0, -0.5, 0.0), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Y);
	//tree.InsertChild(node[1], node[2]);

	//node[3] = new Joint(Vector3(0.0, 0.4, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	//tree.InsertChild(node[2], node[3]);

	//node[3] = new Joint(Vector3(0.0, 1.2, 0.0), zero,EFFECTOR);
	//tree.InsertChild(node[2], node[3]);

	//node[4] = new Joint(Vector3(0.0, 1.2, 0.0), zero,EFFECTOR);
	//tree.InsertChild(node[3], node[4]);
	//test = &tree; // to remove

	node[0] = new Joint(Vector3(0.0, -0.5, 0.0), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Y);
	tree.InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, -0.5, 0.0), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, -0.5, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Z);
	tree.InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 0.4, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	tree.InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 0.4, 0.0), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 1.2, 0.0), zero,EFFECTOR);
	tree.InsertChild(node[4], node[5]);
	test = &tree; // to remove
}

static void matrixToArray( float * tab, const Matrix4d& mat4 )
{
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			tab[ 4*i + j ] = (float)mat4(i,j);
		}
	}
}


static void vectToArray( float * tab, const Vector4d& vect )
{
	for( int i =0; i< 3; ++i )
	{
		tab[i] = (float)vect(i);
	}
}

/**
Drawstuff stuff : 
*/

static void DrawJoint( Joint* joint, Matrix4d& currentTransform )
{
	float length = 1.6f;
	//joint->AddToTheta( Pi / 240. );
	
if ( joint->IsEffector() )
{
	//joint->AddToTheta( Pi / 2400. );
}

	//joint->AddToTheta( Pi / 24000. );

//std::cout << Rotx4( joint->GetTheta() ) << std::endl << Translate( joint->GetR() ) << std::endl << Rotx4( joint->GetTheta() ) + Translate( joint->GetR() ) << std::endl;
	
	
	//draw line between positions
	float from[3];
	vectToArray( from, currentTransform.col(3) );

	Matrix4d jointTransform = Translate( joint->GetR() ); // translation of current joint
	switch( joint->GetRotation() )
	{
		case X:
			jointTransform = jointTransform + Rotx4( joint->GetTheta() );
			break;
		case Y:
			jointTransform = jointTransform + Roty4( joint->GetTheta() );
			break;
		case Z:
			jointTransform = jointTransform + Rotz4( joint->GetTheta() );
			break;
	}
	//currentTransform = currentTransform * ( Rotz4( joint->GetTheta() ) + Translate( joint->GetR() ) );
	currentTransform = currentTransform * jointTransform;
//std::cout << currentTransform << std::endl;

	float R[12];
	matrixToArray( R, currentTransform );
	//cout << currentTransform << endl;
    dsSetColor(1.0,0.0,0.0);
	float ps[3];
	vectToArray( ps, currentTransform.col(3) );
	//= {currentTransform(0,3), currentTransform(1,3), currentTransform(2,3)};
	//double ps[3] = {0,0,0};
	dsDrawSphere (ps, R, 0.05);

	//draw line between positions
	if( joint->pRealparent_ )
		dsDrawLine( from, ps );

    dsSetColor(0.0,1.0,0.0);
	Vector3 pos = joint->GetS();
	for( int j =0; j< 3; ++j )
	{
		ps[ j ] = float(pos(j));
	}
	ps[ 2 ] = ps[ 2 ] + 0.5f;
	dsDrawSphere (ps, R, 0.05);

	//draw line between positions
	from[ 2 ] = from[ 2 ] + 0.5f;
	if( joint->pRealparent_ )
		dsDrawLine( from, ps );
}


static void DrawTree( Tree* tree )
{
	tree->Compute();
	//joint->AddToTheta( Pi / 240. );
	Matrix4d m =  Matrix4d::Identity();
	//cout << m << endl;
	Joint* joint = tree->GetRoot();
	//joint->AddToTheta( Pi / 2400. );
	while ( joint ) {
		DrawJoint( joint, m );
		joint = ( joint->IsEffector() ? 0 : tree->GetSuccessor( joint ) );
		/*if (joint )
		{
			joint->AddToTheta( Pi / 240. );
		}*/
	}
	
	tree->ComputeJacobian();
}


static void simLoop (int pause)
{
	DrawTree(test);
}

void start()
{
    static float xyz[3] = {0.0,-3.0,1.0};
    static float hpr[3] = {90.0,0.0,0.0};
    dsSetViewpoint (xyz,hpr);
}



int main(int argc, char *argv[])
{
	Tree treeY;
	//Jacobian *jacobY;
	Joint* joints[5];
	BuildTree(joints,treeY);
	treeY.Init();
	treeY.Compute();
	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
	fn.command = &command;
    fn.stop    = 0;
    fn.path_to_textures = "./textures";
    dsSimulationLoop (argc,argv,352,288,&fn);

    return 0;
}
