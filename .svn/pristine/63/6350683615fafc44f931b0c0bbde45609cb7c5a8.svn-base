
#include "TreeFactory.h"
#include "RobotFactory.h"
#include "Robot.h"
#include "Tree.h"

#include <vector>

using namespace matrices;

namespace factories
{
const Vector3 unitx(1, 0, 0);
const Vector3 unity(0, 1, 0);
const Vector3 unitz(0, 0, 1);
const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
const Vector3 zero(0,0,0);

struct RobotFactoryPimpl{
	RobotFactoryPimpl()
	{
		// NOTHING
	}
	
	~RobotFactoryPimpl()
	{
		// NOTHING
	}

	// TODO Joint that do not move

	Robot* CreateHuman(const Matrix4& robotBasis) const
	{
		Robot* res = new Robot(robotBasis);
		//Tree* rightArm = treeFact_.CreateTree( factories::Arm, Vector3(0.0, 0.0, 2.7), 3);
		//Tree* leftArm  = treeFact_.CreateTree( factories::Arm, Vector3(0.0, 1.5, 2.7), 4);
		Tree* rightLeg = treeFact_.CreateTree( factories::Leg, Vector3(0.0, 0.5, 1.7), 0);
		Tree* leftLeg  = treeFact_.CreateTree( factories::Leg, Vector3(0.0, 1. , 1.7), 1);
		//res->AddTree(leftArm);
		//res->AddTree(rightArm);
		res->AddTree(leftLeg);
		res->AddTree(rightLeg);
		/*rightLeg->LockTarget(rightLeg->GetTarget());
		leftLeg->LockTarget(leftLeg->GetTarget());*/

		rightLeg->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightLeg->GetPosition() + Vector3( -0.3, 0, -1.4)));
		leftLeg ->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), leftLeg->GetPosition()  + Vector3( 0.3, 0, -1.4)));

		Tree* torso  = treeFact_.CreateTree( factories::HumanTorso, Vector3(0.0, 0.75, 1.7), 2);
		res->AddTorsoAndHead(torso);
		return res;
	}

	Robot* CreateQuadruped(const Matrix4& robotBasis) const
	{
		// TODO Remove order neccessity to create ids ...
		Robot* res = new Robot(robotBasis);
		factories::TreeFactory factory;
		Tree* rightLeg = treeFact_.CreateTree( factories::QuadrupedLegRight, Vector3(0.0, 0.5, 1.7), 0);
		Tree* leftLeg  = treeFact_.CreateTree( factories::QuadrupedLegLeft, Vector3(0.0, 1. , 1.7), 1);
		Tree* leftArm  = treeFact_.CreateTree( factories::QuadrupedLegLeft, Vector3(1.5, 1. , 1.7), 2);
		Tree* rightArm = treeFact_.CreateTree( factories::QuadrupedLegRight, Vector3(1.5, 0.5, 1.7), 3);
		res->AddTree(rightLeg);
		res->AddTree(leftLeg);
		res->AddTree(leftArm);
		res->AddTree(rightArm);
		/*rightLeg->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightLeg->GetPosition() + Vector3(-0.3, 0, -1.3)));
		leftLeg ->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), leftLeg->GetPosition()  + Vector3( 0.5, 0, -1.3)));
		rightArm->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightArm->GetPosition() + Vector3( 0.3, 0, -1.3)));*/

		rightLeg->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightLeg->GetPosition() + Vector3( -0.3, 0, -1.4)));
		leftLeg ->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), leftLeg->GetPosition()  + Vector3( 0.3, 0, -1.4)));
		rightArm->LockTarget(matrix4TimesVect3(res->ToWorldCoordinates(), rightArm->GetPosition() + Vector3( 0.4, 0, -1.4)));
		leftArm->LockTarget (matrix4TimesVect3(res->ToWorldCoordinates(), leftArm->GetPosition()  + Vector3( -0.4, 0, -1.4)));

		Tree* torso  = treeFact_.CreateTree( factories::QuadrupedTorso, Vector3(0.0, 0.75, 1.8), 4);
		res->AddTorsoAndHead(torso);
		return res;
	}

	TreeFactory treeFact_;
};
}

using namespace factories;

RobotFactory::RobotFactory()
	: pImpl_(new RobotFactoryPimpl())
{
	// NOTHING
}


RobotFactory::~RobotFactory()
{
	// NOTHING
}

Robot* RobotFactory::CreateRobot(const eRobots robots, const Matrix4& robotBasis) const
{
	switch (robots)
		{
			case Human:
				{
					return pImpl_->CreateHuman(robotBasis);
				}
			case Quadruped:
				{
					return pImpl_->CreateQuadruped(robotBasis);
				}
			default:
				throw(std::exception("unknown robot type"));
		}
}


