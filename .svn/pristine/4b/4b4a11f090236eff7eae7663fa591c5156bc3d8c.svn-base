
#include "SupportPolygon.h"
#include "SupportPolygonVisitor_ABC.h"
#include "Robot.h"
#include "Tree.h"

#include "World.h"

#include<Eigen/StdVector>

using namespace matrices;
using namespace Eigen;

using namespace std;

struct SupportPolygonPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	SupportPolygonPImpl(const Robot& robot)
	{
		const Robot::T_Tree& trees = robot.GetTrees();
		for(Robot::T_TreeCIT it = trees.begin(); it!= trees.end(); ++it)
		{
			if((*it)->IsLocked())
			{
				points_.push_back((*it)->GetEffectorPosition(0));
			}
		}
		if(points_.size() > 2) // add last point only if already have a polygon
		{
			points_.push_back(points_[0]);
		}
	}

	~SupportPolygonPImpl()
	{
		// NOTHING
	}

	// isLeft(): tests if a point is Left|On|Right of an infinite line.
	//    Input:  three points P0, P1, and P2
	//    Return: >0 for P2 left of the line through P0 and P1
	//            =0 for P2 on the line
	//            <0 for P2 right of the line
	//    See: the January 2001 Algorithm "Area of 2D and 3D Triangles and Polygons"
	NUMBER isLeft( const Vector3& P0, const Vector3& P1, const Vector3& P2 )
	{
		return ( (P1.x() - P0.x()) * (P2.y() - P0.y())
				- (P2.x() - P0.x()) * (P1.y() - P0.y()) );
	}

	// source http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm#wn_PinPolygon()
	// wn_PnPoly(): winding number test for a Vector3 in a polygon
	//      Input:   P = a Vector3,
	//               points_ = Point vector of size n+1 with points_[n]=points_[0]
	//      Return:  wn = the winding number (=0 only if P is outside points_[])
	bool InPolygon ( const Vector3& P )
	{
		int    wn = 0;    // the winding number counter
		int n = points_.size() - 1;
		if(n < 0)
		{
			return false;
		}
		else if(n == 0)
		{
			return( points_[0] == P);
		}
		else if(n == 1)
		{
			throw( std::exception("TODO : handle segment"));
		}

		// loop through all edges of the polygon
		for (int i=0; i<n; i++) 
		{   // edge from points_[i] to points_[i+1]
			if (points_[i].y() <= P.y()) 
			{   // start y <= P.y()
				if (points_[i+1].y() > P.y())      // an upward crossing
				{
					if (isLeft( points_[i], points_[i+1], P) > 0)  // P left of edge
						++wn;            // have a valid up intersect
				}
			}
			else 
			{   // start y > P.y() (no test needed)
				if (points_[i+1].y() <= P.y())     // a downward crossing
				{
					if (isLeft( points_[i], points_[i+1], P) < 0)  // P right of edge
						--wn;            // have a valid down intersect
				}
			}
		}
		return !( wn == 0 );
	}

	typedef std::vector<matrices::Vector3,Eigen::aligned_allocator<matrices::Vector3>> T_Point;
	T_Point points_;
};

SupportPolygon::SupportPolygon(const Robot& robot)
	: pImpl_(new SupportPolygonPImpl(robot))
{
	//TODO
}

SupportPolygon::~SupportPolygon()
{
	// NOTHING
}

void SupportPolygon::Accept(SupportPolygonVisitor_ABC* visitor) const
{
	for(SupportPolygonPImpl::T_Point::const_iterator it=pImpl_->points_.begin(); it != pImpl_->points_.end(); ++it)
	{
		visitor->Visit(*it);
	}
}


bool SupportPolygon::Contains(const matrices::Vector3& aPoint) const
{
	// TODO
	return pImpl_->InPolygon(aPoint);
}

