
#include "IKSolver.h"
#include "Tree.h"
#include "Sample.h"

using namespace matrices;
using namespace Eigen;

IKSolver::IKSolver( const float espilon, const float treshold )
: epsilon_(espilon)
, treshold_(treshold)
{
	// NOTHING
}

IKSolver::~IKSolver()
{
	// NOTHING
}

bool IKSolver::ComputeJointVelocityNoNullSpace( Tree& tree, const Vector3& target, VectorXd& velocities ) const
{
	// Pseudo inverse method : introduction to inverse kin. with jacob... R. Bus
	// TODO
	Vector3 force = tree.GetEffectorPosition(tree.GetNumEffector()-1) - target; //TODO we only have one effector  so weird huh ?
	if( force.norm() < treshold_) // reached treshold
	{
		return true;
	}
	//q' = tr(J) * force

	//VectorXd qVel = (tree.jacobian.transpose() * force);// *stepSize_;
	//velocities = (tree.jacobian.transpose() * force) * 0.01; // Jacobian transpose
	velocities = (tree.jacobianInverse * ( force / force.norm() * 0.1 )); // Jacobian inverse
	return false;
}

void IKSolver::UpdateTree( Tree& tree, const VectorXd& velocities ) const
{
	for( int i = 1; i <= velocities.rows(); ++i ) // starting at 1 %*ù$ù
	{
		tree.GetJoint(i)->AddToTheta(-velocities(i-1));
	}
}

void IKSolver::PartialAvoidSingularities( Tree& tree, const Vector3& target, Eigen::VectorXd& velocities ) const
{
	VectorXd nullSpaceVelocities(velocities.rows());
	for( int i =1; i<= velocities.rows() ;++i)
	{
		Sample save(tree); // saving previous tree

		// force manip
		float previousForceMan = tree.ComputeForceManipulability(*tree.directionForce_);
		float previousManipulability = tree.ComputeManipulability();
		tree.GetJoint(i)->AddToTheta(epsilon_);
		tree.Compute();
		tree.ComputeJacobian();
		nullSpaceVelocities(i-1) = ( previousManipulability + tree.ComputeManipulability() ) / epsilon_;
		nullSpaceVelocities(i-1) += ( previousForceMan + tree.ComputeForceManipulability(*tree.directionForce_) ) / epsilon_;
		save.LoadIntoTree(tree); // loading it
		//test to clamp velocities
		UpdateTree(tree, velocities);
	}
	velocities += (tree.Identitymin * nullSpaceVelocities);
}


bool IKSolver::StepForceManipulability( Tree& tree, const Vector3& target, const Vector3& direction ) const
{
	VectorXd velocities;
	if( !ComputeJointVelocityNoNullSpace(tree, target, velocities) )
	{
		PartialForceManDerivatives(tree, direction, velocities);
		//test to clamp velocities
		UpdateTree(tree, velocities);
		return false;
	}
	return true;
}

bool IKSolver::StepForceAndAvoidManipulability( Tree& tree, const Vector3& target, const Vector3& direction ) const
{
	VectorXd velocities;
	if( !ComputeJointVelocityNoNullSpace(tree, target, velocities) )
	{
		PartialAvoidSingularities(tree, target, velocities);
		//test to clamp velocities
		UpdateTree(tree, velocities);
		return false;
	}
	return true;
}

bool IKSolver::Step( Tree& tree, const Vector3& target ) const // Pseudo inverse method : introduction to inverse kin. with jacob... R. Buss
{
	VectorXd velocities;
	if( !ComputeJointVelocityNoNullSpace(tree, target, velocities) )
	{
		UpdateTree(tree, velocities);
		return false;
	}
	return true;
}

void IKSolver::PartialForceManDerivative(Tree& tree, const Vector3& direction, VectorXd& velocities, const int joint) const
{
	//float previousMan = tree.ComputeForceManipulability(direction);
	float previousMan = tree.ComputeForceManipulability(direction);

	Sample save(tree); // saving previous tree
	tree.GetJoint(joint)->AddToTheta(epsilon_);
	tree.Compute();
	tree.ComputeJacobian();
	//velocities(joint-1) = 0.01 * ( previousMan + tree.ComputeForceManipulability(direction) ) / epsilon_;
	velocities(joint-1) = ( previousMan + tree.ComputeForceManipulability(direction) ) / epsilon_;
	save.LoadIntoTree(tree); // loading it
}


void IKSolver::PartialForceManDerivatives(Tree& tree, const Vector3& direction, VectorXd& velocities) const
{
	VectorXd nullSpaceVelocities(velocities.rows());
	for( int i =1; i<= velocities.rows() ;++i)
	{
		PartialForceManDerivative( tree, direction, nullSpaceVelocities, i);
	}
	velocities += (tree.Identitymin * nullSpaceVelocities);
}
