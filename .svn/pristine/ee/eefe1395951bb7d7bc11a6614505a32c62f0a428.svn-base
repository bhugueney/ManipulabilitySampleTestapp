
#include "FilterDistanceObstacle.h"

#include "Obstacle.h"
#include "Robot.h"
#include "Sample.h"

#include <math.h>

using namespace matrices;
using namespace Eigen;

struct FilterDPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW

	FilterDPImpl(NUMBER treshold, const Obstacle& obstacle, const Robot& robot)
	: treshold_(treshold)
	{
		//toObstacleCoordinates_ = robot.ToWorldCoordinates() * obstacle.BasisInv();
		toObstacleCoordinates_ = obstacle.BasisInv() * robot.ToWorldCoordinates();
		obsW_ = obstacle.GetW(); obsH_ = obstacle.GetH();
	}

	~FilterDPImpl()
	{
		// NOTHING
	}
	
	NUMBER treshold_;
	Matrix4 toObstacleCoordinates_;
	NUMBER obsW_, obsH_;

};

FilterDistanceObstacle::FilterDistanceObstacle(NUMBER treshold, const Obstacle& obstacle, const Robot& robot)
	: pImpl_(new FilterDPImpl(treshold, obstacle, robot))
{
	// NOTHING
}

FilterDistanceObstacle::~FilterDistanceObstacle()
{
	// NOTHING
}

bool FilterDistanceObstacle::ApplyFilter(const Sample& sample) const
{
	// check that sample position is inside obstacle radius and not too far from its plan
	if(sample.GetPosition()(0) <=0 ) // we want to move forward
	{
		return false;
	}
	Vector3 center = matrix4TimesVect3(pImpl_->toObstacleCoordinates_, sample.GetPosition());
	NUMBER xc, yc;
	xc = center(0); yc = center(1);
	return (abs(center(2)) <= pImpl_->treshold_) && (xc >= 0 && xc <= pImpl_->obsW_) && (yc >= 0 && yc <= pImpl_->obsH_);
}

