#include "sampling/SampleGeneratorVisitor_ABC.h"
#include "sampling/SampleGenerator.h"
#include "sampling/Sample.h"

#include "RobotRootSampler.h"
#include "FilterDistance.h"

#include <algorithm>    // std::min, max
#include <stdlib.h>     /* srand, rand */
#include <vector>     /* srand, rand */

using namespace matrices;

namespace
{
	Boundaries ComputeBoundaries(const Robot& robot)
	{
		Boundaries b;
		b.minX_ = -10000;
		b.maxX_ =  10000;
		b.minY_ = b.minX_;
		b.maxY_ = b.maxX_;
		b.minZ_ = b.minX_;
		b.maxZ_ = b.maxX_ ;
		int i = 0; Tree* tempTree;
		const matrices::Matrix4& worldTransform = robot.ToWorldCoordinates();
		const matrices::Matrix4& robotTransform = robot.ToRobotCoordinates();
		for(Robot::T_TreeCIT it = robot.GetTrees().begin(); it != robot.GetTrees().end(); ++it)
		{
			tempTree = (*it);
			if(tempTree->IsLocked())
			{
				// removing tree offset from center
				const matrices::Vector3 position = matrices::matrix4TimesVect3(worldTransform, tempTree->GetEffectorPosition(tempTree->GetNumEffector()-1)) - tempTree->GetRoot()->GetR();
				NUMBER radius = tempTree->GetBoundaryRadius();
				b.minX_ = std::max(b.minX_, position.x() - radius); 
				b.maxX_ = std::min(b.maxX_, position.x() + radius);
				b.minY_ = std::max(b.minY_, position.y() - radius); 
				b.maxY_ = std::min(b.maxY_, position.y() + radius);
				b.minZ_ = std::max(b.minZ_, position.z() - radius); 
				b.maxZ_ = std::min(b.maxZ_, position.z() + radius);
			}
		}
		return b;
	}

	struct HandleLockedVisitor : SampleGeneratorVisitor_ABC
	{
		HandleLockedVisitor(const World& world)
			:world_(world)
			, currentBest_(0)
		{
			// NOTHING
		}

		~HandleLockedVisitor()
		{
			// NOTHING
		}

		virtual void Visit(const Robot& robot, /*const*/ Tree& tree, Sample& sample)
		{
			//TODO Manipulability and other constraints here
			if(currentBest_ == 0 && !world_.IsColliding(robot, tree))
			{
				currentBest_ = &sample;
			}
		}
		Sample* currentBest_;
		const World& world_;
	};

	typedef std::pair<int, Sample*> Handle;
	typedef std::vector<Handle> T_Handle;
	bool CheckTree(Robot& robot, const World& world)
	{
		T_Handle handles;
		Tree* tempTree; int i = 0;
		SampleGenerator* sg = SampleGenerator::GetInstance();

		bool ok = true;
		for(Robot::T_TreeCIT it = robot.GetTrees().begin(); ok && it != robot.GetTrees().end(); ++it, ++i)
		{
			tempTree = (*it);
			if(tempTree->IsLocked())
			{
				HandleLockedVisitor hv(world);
				FilterDistance filter(0.05, *tempTree, matrices::matrix4TimesVect3(robot.ToRobotCoordinates(), tempTree->GetTarget()));
				sg->Request(robot, *tempTree, &hv, filter);
				if(hv.currentBest_)
				{
					handles.push_back(std::make_pair(i, hv.currentBest_));
				}
				else
				{
					ok = false;
				}
			}
		}
		if(ok)
		{
			for(T_Handle::const_iterator it = handles.begin(); it != handles.end();++it)
			{
				it->second->LoadIntoTree(*(robot.GetTree(it->first)));
			}
		}
		return ok;
	}
}

RobotRootSampler::RobotRootSampler(const World& world, const Robot& robot)
	: world_(world)
	, robot_(robot)
	, boundaries_(ComputeBoundaries(robot))
{
	// NOTHING
}

RobotRootSampler::~RobotRootSampler()
{
	// NOTHING
}


Robot* RobotRootSampler::GenerateSample() const
{
	int i = 0; Robot* rob = robot_.Clone();
	while(i < 1000)
	{
		NUMBER x = boundaries_.minX_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxX_-boundaries_.minX_)));
		NUMBER y = boundaries_.minY_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxY_-boundaries_.minY_)));
		NUMBER z = boundaries_.minZ_ + static_cast <NUMBER> (rand()) /( static_cast <NUMBER> (RAND_MAX/(boundaries_.maxZ_-boundaries_.minZ_)));

		rob->MoveTo(matrices::Vector3(x, y, z));
		if(CheckTree(*rob, world_))
		{
			return rob;
		}
	}
	delete rob;
	return 0;
}

Robot* RobotRootSampler::GenerateSampleWithDir(const matrices::Vector3& direction) const
{
	// TODO
	return 0;
}