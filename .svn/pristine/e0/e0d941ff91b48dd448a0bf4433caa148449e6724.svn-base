/**
* \file PRM.h
* \brief PRM implementation as a generic undirected Graphs through A star navigation
* \author Steve T.
* \version 0.1
* \date 10/02/2014
*
* This file contains the methods that sample
* configurations so as to create a PRM.
* 
*/
#ifndef _CLASS_PRM
#define _CLASS_PRM

#include "Graph.h"
#include "kinematic/Robot.h"
#include "world/World.h"

#include "State.h"

#include <algorithm>
#include <vector>
#include <list>
#include <map>

namespace roadmap
{
/// \class PRM
/// \brief A graph factory used as an implementation of the PRM algortihm.
/// Positions are sampled from a starting one, with an "oriented-sampling" phase.
/// From a position analyze possible transition and try to sample a new configuration.
/// If a position is found then we know for sure it is the neighbour of its parent.
/// As a first implementation, our graph is acyclic, so no other neighbours are generated
/// TODO: no need for this to be a class, this is just a factory really
class PRM
{
public:
	typedef astar::Graph<Robot, float, 100000, int, false> graph_t;
	
public:
	///\brief Constructor
	///  \param nbNodes the number of nodes we want our PRM graph to contain.
	///  \param startConfiguration initial configuration of the robot
	 PRM(const int /*nbNodes*/, const Robot& /*startConfiguration*/, const World& /*world*/, const statepostures::StateTree& /*stateTree*/);

	///\brief Destructor
	 ~PRM();

private:
	PRM(const PRM&);
	PRM& operator=(const PRM&);
	 
public:

public:
	const graph_t* graph_;
};
} //namespace roadmap
#endif //_CLASS_PRM
