#include "kinematic/Joint.h"
#include "kinematic/Tree.h"
#include "kinematic/Robot.h"

#include "Obstacle.h"
#include "World.h"
#include "kinematic/SampleGenerator.h"
#include "PostureSolver.h"

#include "MatrixDefs.h"
#include "Pi.h"

#include "DrawPostures.h"
#include "DrawRobot.h"
#include "DrawWorld.h"

#include "Trajectory.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#ifdef WIN32
#include <windows.h>
#endif

#include <iostream>
#include <vector>

#define RADIAN(X)	((X)*DegreesToRadians)

using namespace matrices;
using namespace Eigen;
using namespace std;

// main object
DrawPostures* pDrawPosturesTEST;


Robot* pRobot;
DrawRobot* pDrawRobot;
World* pWorld;
DrawWorld* pDrawWorld;

//Direction of robot movement
Vector3* pDirection;

//basis for arrow drawing
const Vector3 from(0.5, 0, 0.5);

//camera
static float xyz[3] = {-10.0,1,1.0};
static float hpr[3] = {0.0,0.0,0.0};

static bool handleDirection(int cmd)
{
	bool found = false;
	switch (cmd)
		{
		case 'o':
			found = true;
			pDirection = new Vector3(0,0,1);
			break;
		case 'l':
			found = true;
			pDirection = new Vector3(0,0,-1);
			break;
		case 'm':
			found = true;
			pDirection = new Vector3(1,0,0);
			break;
		case 'k':
			found = true;
			pDirection = new Vector3(-1,0,0);
			break;
		case 'i':
			found = true;
			pDirection = new Vector3(0,1,0);
			break;
		case 'p':
			found = true;
			pDirection = new Vector3(0,-1,0);
			break;
		}
	return found;
}

void command(int cmd)   /**  key control function; */
{
	if (!handleDirection(cmd))
	{
		Vector3 trX(0.01, 0, 0);
		Vector3 trY(0,0.01,  0);
		switch (cmd)
		{			
		case 't' :
			pRobot->Reset();
		break;
		case 'r' :
			pRobot->Rest();
		break;
		case 'z' :
			xyz[0] += 0.01f;
			pRobot->Translate(trX);
		dsSetViewpoint (xyz,hpr);
		break;
		case 's' :
			xyz[0] -= 0.01f;
			pRobot->Translate(-trX);
		dsSetViewpoint (xyz,hpr);
		break;
		case 'q' :
			xyz[1] += 0.01f;
			pRobot->Translate(trY);
		dsSetViewpoint (xyz,hpr);
		break;
		case 'd' :
			xyz[1] -= 0.01f;
			pRobot->Translate(-trY);
		dsSetViewpoint (xyz,hpr);
		break;
		}
	}
}

void BuildRobot(Robot& robot)
{
	//principal axes constants
	const Vector3 unitx(1, 0, 0);
	const Vector3 unity(0, 1, 0);
	const Vector3 unitz(0, 0, 1);
	const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
	const Vector3 zero(0,0,0);

	/*RIGHT ARM*/
	Joint* node[6];
	Tree* rightArm = new Tree(0);
	node[0] = new Joint(Vector3(0.0, 0.0, 1.7), unity, JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0),   Y);
	rightArm->InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, 0.0, 1.7), unitx, JOINT, RADIAN(-135) , RADIAN(135) , RADIAN(0),   X);
	rightArm->InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, 0.0, 1.7), unitz, JOINT, RADIAN(-120)  , RADIAN(45)  , RADIAN(0),   Z);
	rightArm->InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 0.0, 0.9), unity, JOINT, RADIAN(-90)  , RADIAN(45)  , RADIAN(-30), Y);
	rightArm->InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 0.0, 0.9), unitx, JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0.),  X);
	rightArm->InsertChild(node[3], node[4]);
 
	node[5] = new Joint(Vector3(0.0, 0.0, 0.0), zero, EFFECTOR);
	rightArm->InsertChild(node[4], node[5]);

	robot.AddTree(rightArm);

	/*LEFT ARM*/
	/*Tree* leftArm = new Tree();
	node[0] = new Joint(Vector3(0.0, 1.5, 1.7), unity, JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0),   Y);
	leftArm->InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, 1.5, 1.7), unitx, JOINT, RADIAN(-135) , RADIAN(135) , RADIAN(0),   X);
	leftArm->InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, 1.5, 1.7), unitz, JOINT, RADIAN(-45)  , RADIAN(45)  , RADIAN(0),   Z);
	leftArm->InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 1.5, 0.9), unity, JOINT, RADIAN(-120)  , RADIAN(45)  , RADIAN(-30), Y);
	leftArm->InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 1.5, 0.9), unitx, JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0.),  X);
	leftArm->InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 1.5, 0.0), zero, EFFECTOR);
	leftArm->InsertChild(node[4], node[5]);*/


	Tree* leftArm = new Tree(1, 0);
	node[0] = new Joint(Vector3(0.0, 1.5, 1.7), unity, JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0),    Y);
	leftArm->InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, 1.5, 1.7), unitx, JOINT, RADIAN(-135) , RADIAN(135) , RADIAN(0),    X);
	leftArm->InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, 1.5, 1.7), unitz, JOINT, RADIAN(-45)  , RADIAN(45)  , RADIAN(0),    Z);
	leftArm->InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 1.5, 0.9), unity, JOINT, RADIAN(-120)  , RADIAN(45)  , RADIAN(-30), Y);
	leftArm->InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 1.5, 0.9), unitx, JOINT, RADIAN(-180.), RADIAN(180.) , RADIAN(0.),  X);
	leftArm->InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 1.5, 0.0), zero, EFFECTOR);
	leftArm->InsertChild(node[4], node[5]);

	robot.AddTree(leftArm);
}


void BuildWorld(World& world)
{
	// FORWARD OBSTACLES
	Vector3 p1(-1,1,0.1f);
	Vector3 p2(1,1,0.1f);
	Vector3 p3(1,0,0.1f);
	Vector3 p4(-1,0,0.1f);

	world.AddObstacle(new Obstacle(p1,p2,p3,p4));

	NUMBER pose = -4.f;
	NUMBER posey = 1.f;
	Vector3 p11(pose,posey+ 1,0.5f);
	Vector3 p12(pose+1,posey+ 1,0.5f);
	Vector3 p13(pose+1,posey,0.1f);
	Vector3 p14(pose,posey,0.1f);

	world.AddObstacle(new Obstacle(p11,p12,p13,p14));

	pose = -3.f;
	posey = -0.5f;
	Vector3 p111(pose,posey,1.f);
	Vector3 p121(pose+1,posey,1.f);
	Vector3 p131(pose+1,posey,0.5f);
	Vector3 p141(pose,posey,0.5f);

	world.AddObstacle(new Obstacle(p111,p121,p131,p141));

	pose = 0.5f;
	posey = 1.f;
	Vector3 p21(pose,posey+ 1,0.4f);
	Vector3 p22(pose+1,posey+ 1,0.4f);
	Vector3 p23(pose+1,posey,1.f);
	Vector3 p24(pose,posey,1.f);

	world.AddObstacle(new Obstacle(p21,p22,p23,p24));

	pose = -6.f;
	posey = 3.f;
	// LEFT OBSTACLES
	Vector3 pl1(pose,posey,1.f);
	Vector3 pl2(pose,posey+1,1.f);
	Vector3 pl3(pose,posey+1,0.1f);
	Vector3 pl4(pose,posey,0.1f);

	world.AddObstacle(new Obstacle(pl1,pl2,pl3,pl4));

	pose = -5.f;
	posey = 3.f;
	Vector3 pla(pose,posey+ 1,0.5f);
	Vector3 pla2(pose+1,posey+ 1,0.5f);
	Vector3 pla3(pose+1,posey,0.1f);
	Vector3 pla4(pose,posey,0.1f);
}

/**
Drawstuff stuff :
*/
static void DrawArrow(const Vector3& from, const Vector3& dir)
{
	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	
	Vector3 destdir = from+dir;
	float fr[3];
	float t[3];
	vect3ToArray(fr, from); 
	vect3ToArray(t, destdir); 
	dsDrawLine  (fr, t);
	dsDrawSphere(t, Identity, 0.02f);
}


static void simLoop (int pause)
{
	pRobot->Move(*pDirection, *pWorld);
	pDrawRobot->Draw();
	pDrawWorld->Draw();
	DrawArrow(from, *pDirection);
/*TEST*/
pDrawPosturesTEST->Draw();
/*TEST*/
}

void start()
{
    dsSetViewpoint (xyz,hpr);
}

int main(int argc, char *argv[])
{
	//init robot
	Matrix4 robotBasis(MatrixX::Identity(4,4));
	robotBasis(0,3) = -7;

	Robot robot(robotBasis);
	BuildRobot(robot);
	pRobot = &robot;

	//init DrawRobot
	DrawRobot dRobot(robot);
	pDrawRobot = &dRobot;

	// for now mostly contains obstacles
	World world;
	BuildWorld(world);
	pWorld = &world;

	//init DrawWorld
	DrawWorld dWorld(world);
	pDrawWorld = &dWorld;

	//movement direction
	Vector3 direction(1,0,0);
	pDirection = &direction;


/* TEST */
SampleGenerator* sg = SampleGenerator::GetInstance();
sg->GenerateSamples(robot,1000);
PostureSolver ps(world);
Matrix4 robotBasis2(MatrixX::Identity(4,4));
Trajectory traj;
for(int i =-6; i<0; ++i)
{
	robotBasis2(0,3) = i;
	traj.AddCheckPoint( i+ 6.f, robotBasis2);
}
pDrawPosturesTEST = new DrawPostures(ps);
ps.CreatePostures(robot, *sg, traj);
/*TEST */

	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
	fn.command = &command;
    fn.stop    = 0;
    fn.path_to_textures = "./textures";
    dsSimulationLoop (argc,argv,800,600,&fn);

    return 0;
}
