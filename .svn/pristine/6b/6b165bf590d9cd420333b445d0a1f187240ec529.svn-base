
#include "Joint.h"
#include "Pi.h"
#include "MatrixDefs.h"

#include <math.h>

using namespace matrices;


Joint::Joint(const Vector3& attach, const Vector3& iRotAxis, Purpose purpose, double minTheta, double maxTheta, double restAngle, Rotation rot)
	: r_			(0, 0, 0)
	, purpose_		(purpose)
	, attach_		(attach) 
	, v_			(iRotAxis) // Rotation axis when joints at zero angles
	, theta_		(0)
	, pRealparent_	(0)
	, restAngle_	(restAngle )
	, minTheta_		(minTheta)
	, maxTheta_		(maxTheta)
	, pChild_		(0)
	, rot_(rot)
{
	// NOTHING
}

Joint::Joint(const Vector3& attach, const Vector3& iRotAxis, Purpose purpose, double restAngle, Rotation rot)
	: r_			(0, 0, 0)
	, purpose_		(purpose)
	, attach_		(attach) 
	, v_			(iRotAxis) // Rotation axis when joints at zero angles
	, theta_		(0)
	, pRealparent_	(0)
	, restAngle_	(restAngle)
	, minTheta_		(-Pi)
	, maxTheta_		(Pi)
	, pChild_		(0)
	, rot_(rot)
{
	// NOTHING
}

double Joint::AddToTheta( const double delta )
{ 
	//theta_ += abs( delta ) > 0.01 ? delta / (abs ( delta ) ) * 0.01 : delta;
	theta_ += delta;
	theta_ = (theta_ > maxTheta_) ? maxTheta_ : theta_;
	theta_ = (theta_ < minTheta_) ? minTheta_ : theta_;
	return theta_;
}


// Compute the global position of a single Joint
void Joint::ComputeS(void)
{
	Joint* y = this->pRealparent_;
	Joint* w = this;
	s_ = r_;							// Initialize to local (relative) position
	while ( y ) {
		Rotate( y->v_, s_, y->theta_ );
		y = y->pRealparent_;
		w = w->pRealparent_;
		s_ += w->r_;
	}
}

// Compute the global rotation axis of a single Joint
void Joint::ComputeW(void)
{
	Joint* y = this->pRealparent_;
	w_ = v_;							// Initialize to local rotation axis
	while (y) {
		Rotate(y->v_, w_, y->theta_);
		y = y->pRealparent_;
	}
}

void Joint::InitJoint()
{
	theta_ = restAngle_;
}

void Joint::ToRest()
{
	theta_ = restAngle_;
}

