
#include "Obstacle.h"
#include <math.h>

using namespace matrices;
using namespace Eigen;

Obstacle::Obstacle(const Vector3& p1, const Vector3& p2, const Vector3& p3, const Vector3& p4 )
: p1_( p1 )
, p2_( p2 )
, p3_( p3 )
, p4_( p4 )
{
	Vector3 normal = (p3 - p4).cross(p1 - p4);
	a_ = (float)(normal.x());
	b_ = (float)(normal.y());
	c_ = (float)(normal.z());
	//if (c_ < 0 ) c_ = -c_;
	norm_ = (float)(normal.norm());
	normsquare_ = norm_ * norm_;
	d_ = (float)(-( a_ * p1.x() + b_ * p1.y() + c_ * p1.z() ));
	center_ = p1 + ( ( p4 - p1 ) + ( p2 - p1 ) ) / 2 ;

	basis_ = Matrix4::Zero();
	Vector3 x = ( p3 - p4 ); x.normalize();
	Vector3 y = ( p1 - p4 ); y.normalize();
	normal.normalize();
	basis_.block(0,0,3,1) = x;
	basis_.block(0,1,3,1) = y;
	basis_.block(0,2,3,1) = normal;
	basis_.block(0,3,3,1) = p4;
	basis_(3,3) = 1;
	basisInverse_ = basis_.inverse();

	w_ = (float)((p3 - p4).norm());
	h_ = (float)((p1 - p4).norm());
}

Obstacle::~Obstacle()
{
	// NOTHING
}

NUMBER Obstacle::Distance(const Vector3& point, Vector3& getCoordinates) const
{
	// http://fr.wikipedia.org/wiki/Distance_d%27un_point_%C3%A0_un_plan
	NUMBER lambda = - ( ( a_ * point.x() + b_ * point.y() + c_ * point.z() + d_ ) / normsquare_ );
	getCoordinates(0) = lambda * a_ + point.x();
	getCoordinates(1) = lambda * b_ + point.y();
	getCoordinates(2) = lambda * c_ + point.z();
	return (abs( lambda ) * norm_);
}

//bool Obstacle::ContainsPlanar(const Vector3& point) const
//{
//	double xc, yc, zc;
//	xc = point(0); yc = point(1);
//	return ( ( xc > 0 && xc < w_ ) &&
//		     ( yc > 0 && yc < h_ ) ;
//}
