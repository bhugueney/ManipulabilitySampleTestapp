#include "WorldParser.h"

#include "Simulation.h"

#include "MatrixDefs.h"

using namespace matrices;

WorldParser::WorldParser()
	:manager_(Simulation::GetInstance()->manager_)
{
	// NOTHING
}

WorldParser::~WorldParser()
{
	// NOTHING
}

/*<world>
  <robot type="my element" x=0 y=1 z=2 />
  <obstacles>
	<obstacle> 
		<p0 x="" y="" z=""/>
		<p1 x="" y="" z=""/>
		<p2 x="" y="" z=""/>
		<p3 x="" y="" z=""/>
	</obstacle>
	...
	<obstacle> 
		<p0 x="" y="" z=""/>
		<p1 x="" y="" z=""/>
		<p2 x="" y="" z=""/>
		<p3 x="" y="" z=""/>
	</obstacle>
	...
	<verticalChess> 
		<depth x="" y="" z=""/>
		<p0 x="" y="" z=""/>
		<p3 x="" y="" z=""/>
	</verticalChess>
	...
	<prise> 
		<p0 x="" y="" z=""/>
	</prise>
  </obstacles>
</world>*/
void WorldParser::CreateWorld(const std::string& filename)
{
	int type;
	float x, y, z;
	xml::xifstream xis( filename );
	xis >> xml::start( "world" )
			>> xml::start( "robot" )
				>> xml::attribute( "type", type )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
			>> xml::end
			>> xml::start( "obstacles" )
				>> xml::list(*this, &WorldParser::CreateObstacle)
			>> xml::end;
	CreateRobot(type, x, y, z);
	manager_.Initialize(false);
}

void WorldParser::CreateRobot(const int type, const float x, const float y, const float z) const
{
	matrices::Matrix4 basis(MatrixX::Identity(4,4));
	basis(0,3) = x;
	basis(1,3) = y;
	basis(2,3) = z;
	Simulation::GetInstance()->simpParams_.robotType_ = (manip_core::enums::robot::eRobots)(type);
	Simulation::GetInstance()->simpParams_.robotBasis_ = basis;
}

void WorldParser::CreateObstacle(const std::string& name, xml::xistream& xis) const
{
	matrices::Vector3 p0, p1, p2, p3;
	float x, y, z;
	if(name == "obstacle")
	{
		xis >> xml::start( "p0" )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
		>> xml::end;
		p0 = Vector3(x, y, z);
		xis >> xml::start( "p1" )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
		>> xml::end;
		p1 = Vector3(x, y, z);
		xis >> xml::start( "p2" )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
		>> xml::end;
		p2 = Vector3(x, y, z);
		xis >> xml::start( "p3" )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
		>> xml::end;
		p3 = Vector3(x, y, z);

		manager_.AddObstacle(p0, p1, p2, p3);
	}
	if(name == "verticalchess")
	{
		unsigned int depth;
		xis >> xml::attribute( "depth", depth )
		>>xml::start( "p0" )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
		>> xml::end;
		p0 = Vector3(x, y, z);
		xis >> xml::start( "p1" )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
		>> xml::end;
		p1 = Vector3(x, y, z);
		manager_.GenerateVerticalChess(p0, p1, depth);
	}
	if(name == "prise")
	{
		xis >>xml::start( "p0" )
				>> xml::attribute( "x", x )
				>> xml::attribute( "y", y )
				>> xml::attribute( "z", z )
		>> xml::end;
		p0 = Vector3(x, y, z);
		Vector3 pu(p0(0), p0(1)+0.1, p0(2)+0.1);
		Vector3 pb(p0(0), p0(1)-0.2, p0(2)-0.2);
		manager_.GenerateVerticalChess(pu, pb, 0);
	}
}
