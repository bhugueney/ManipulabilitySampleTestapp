
#ifndef _CLASS_OBSTACLE
#define _CLASS_OBSTACLE

#include "MatrixDefs.h"

//#include "Rennes1\SpatialDataStructure\Selectors\Triangle3D.h"
#include <vector>

class Obstacle {

friend class Intersection;
friend class DrawObstacle;
friend class CollisionHandler;
friend class SampleGenerator;
friend class World;

public:
	typedef std::vector<Obstacle> T_Obstacle;

public:
	//make it clockwise from upper left
	 Obstacle(const matrices::Vector3& /*p1*/, const matrices::Vector3& /*p2*/, const matrices::Vector3& /*p3*/, const matrices::Vector3& /*p4*/);
	~Obstacle();

public:
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	// Minimal distance between the plan described by the obstacle and a point, that is, the distance btw point and its orthonormal projection on the plan
	NUMBER Distance(const matrices::Vector3& /*point*/, matrices::Vector3& /*getCoordinates*/) const; // get coordinates of the projection
	//bool  ContainsPlanar(const matrices::Vector3& /*point*/) const; // point in the plan expressed in local coordinates	

	const matrices::Vector3& Center() const { return center_; }
	const matrices::Matrix4& Basis   () const { return basis_; }
	const matrices::Matrix4& BasisInv() const { return basisInverse_; }

	NUMBER GetD() const { return d_; }
	NUMBER GetW() const { return w_; }
	NUMBER GetH() const { return h_; }

private:
	const matrices::Vector3 p1_;
	const matrices::Vector3 p2_;
	const matrices::Vector3 p3_;
	const matrices::Vector3 p4_;
		  matrices::Vector3 center_;

	matrices::Matrix4 basis_; // transformation matrix to world basis (on p4)
	matrices::Matrix4 basisInverse_; // transformation matrix to rectangle basis (on p4)

	NUMBER a_;
	NUMBER b_;
	NUMBER c_;
	NUMBER d_;
	NUMBER norm_;
	NUMBER normsquare_;
	NUMBER w_;
	NUMBER h_;

private:
	/*typedef Rennes1::Math::Vector3<double>									  Vector3f;
	typedef Rennes1::SpatialDataStructure::Selectors::Triangle3D<double>	  Triangle3Df;
	Triangle3Df* triangle1_;
	Triangle3Df* triangle2_;*/
};

#endif //_CLASS_OBSTACLE