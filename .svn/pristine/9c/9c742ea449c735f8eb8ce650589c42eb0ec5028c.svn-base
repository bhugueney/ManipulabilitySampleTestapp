#include "kinematic/Tree.h"
#include "kinematic/Sample.h"
#include "kinematic/SampleGenerator.h"

#include "SimpleSampleVisitor.h"

#include "kinematic/MatrixDefs.h"
#include "kinematic/Pi.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#ifdef WIN32
#include <windows.h>
#endif

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <GL/glui.h>

#include <iostream>

using namespace std;

#define RADIAN(X)	((X)*DegreesToRadians)

using namespace matrices;
using namespace Eigen;

Tree* test; // TO F... REMOVE

SimpleSampleVisitor visitor;
SampleGenerator* generator = SampleGenerator::GetInstance();

//static void ViewOrtho(int x, int y)							// Set Up An Ortho View
//{
//	glMatrixMode(GL_PROJECTION);					// Select Projection
//	glPushMatrix();							// Push The Matrix
//	glLoadIdentity();						// Reset The Matrix
//	glOrtho( 0, x , y , 0, -40, 40 );				// Select Ortho Mode
//	glMatrixMode(GL_MODELVIEW);					// Select Modelview Matrix
//	glPushMatrix();							// Push The Matrix
//	glLoadIdentity();						// Reset The Matrix
//}
//
//static void ViewPerspective(void)							// Set Up A Perspective View
//{
//	glMatrixMode( GL_PROJECTION );					// Select Projection
//	glPopMatrix();							// Pop The Matrix
//	glMatrixMode( GL_MODELVIEW );					// Select Modelview
//	glPopMatrix();							// Pop The Matrix
//}

void GetOGLPos(int x, int y, Vector3& res)
{
    GLint viewport[4];
    GLdouble modelview[16];
    GLdouble projection[16];
    GLfloat winX, winY, winZ;
    GLdouble posX, posY, posZ;
 
    glGetDoublev( GL_MODELVIEW_MATRIX, modelview );
    glGetDoublev( GL_PROJECTION_MATRIX, projection );
    glGetIntegerv( GL_VIEWPORT, viewport );
 
    winX = (float)x;
    winY = (float)viewport[3] - (float)y;
    glReadPixels( x, int(winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &winZ );
 
    gluUnProject( winX, winY, winZ, modelview, projection, viewport, &posX, &posY, &posZ);
 
	res.x() = posX;
	res.y() = posY;
	res.z() = posZ;
	//return CVector3(posX, posY, posZ);
}

static bool handleDirection( int cmd )
{
	bool found = false;
	double delta = 0.05;
	Vector3* dir = test->direction_;
	switch (cmd)
		{
		case 'o':
			found = true;
			test->direction_->z() = test->direction_->z() + delta;
			break;
		case 'l':
			test->direction_->z() = test->direction_->z() - delta;
			found = true;
			break;
		case 'm':
			test->direction_->x() = test->direction_->x() + delta;
			found = true;
			break;
		case 'k':
			test->direction_->x() = test->direction_->x() - delta;
			found = true;
			break;
		}
		if( found ) 
		{
			test->direction_->normalize();
		}
	return found;
}

void command(int cmd)   /**  key control function; */
{
	Sample * res;
	if (! handleDirection(cmd))
	{
		Joint* joint( 0 );
		int sens = 1;
		switch (cmd)
		{
		case 'w' :
			test->ToRest();
			break;
		case 'x':
			{	//force
				visitor.Configure(1.f, 0.f);
				res = visitor.Run(*generator, *(test->direction_));
				if(res)
				{
					res->LoadIntoTree(*test);
				}
				//generator->Accept(visitor);
				break;
			}
		case 'c':
			test->ApproximateForceManipulabilityBruteForce(); 
			break;
		case 'v':
			//vitesse
			{
				visitor.Configure(0.f, 1.f);
				res = visitor.Run(*generator, *(test->direction_));
				if(res)
				{
					res->LoadIntoTree(*test);
				}
				//generator->Accept(visitor);
				break;
			}
			case 'n':
			//controle vitesse, grande force
			{
				visitor.Configure(1.f, -1.f);
				res = visitor.Run(*generator, *(test->direction_));
				if(res)
				{
					res->LoadIntoTree(*test);
				}
				//generator->Accept(visitor);
				break;
			}
		case 'b':
			test->ApproximateVelocityManipulabilityBruteForce(); 
			break;
		case 'a':
			joint = test->GetJoint(1); // increases THETA[1] when a key is pressed
			break;
		case 'z':
			joint = test->GetJoint(2);
			break;
		case 'e':
			joint = test->GetJoint(3);
			break;
		case 'r':
			joint = test->GetJoint(4);
			break;
		case 't':
			joint = test->GetJoint(5);
			break;
		case 'q':
			sens = -1;
			joint = test->GetJoint(1); // increases THETA[1] when a key is pressed
			break;
		case 's':
			sens = -1;
			joint = test->GetJoint(2);
			break;
			sens = -1;
		case 'd':
			sens = -1;
			joint = test->GetJoint(3);
			break;
		case 'f':
			sens = -1;
			joint = test->GetJoint(4);
			break;
		case 'g':
			sens = -1;
			joint = test->GetJoint(5);
			break;
		}
		if (joint)
		{
			joint->AddToTheta(0.05 * sens);
		}
	}
}

void BuildTree(Joint *node[], Tree &tree)
{
	const Vector3 unitx(1, 0, 0);
	const Vector3 unity(0, 1, 0);
	const Vector3 unitz(0, 0, 1);
	const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
	const Vector3 zero(0,0,0);

	/*VERTICAL ARM*/
	
	node[0] = new Joint(Vector3(0.0, 0.0, 1.7), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Y);
	tree.InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, 0.0, 1.7), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, 0.0, 1.7), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Z);
	tree.InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 0.0, 0.9), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Y);
	tree.InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 0.0, 0.9), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 0.0, 0.0), zero,EFFECTOR);
	tree.InsertChild(node[4], node[5]);

	/*HORIZONTAL ARM*/
	/*
	node[0] = new Joint(Vector3(0.0, -0.5, 0.0), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Y);
	tree.InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, -0.5, 0.0), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, -0.5, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Z);
	tree.InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 0.4, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	tree.InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 0.4, 0.0), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 1.2, 0.0), zero,EFFECTOR);
	tree.InsertChild(node[4], node[5]);*/
	
	
	test = &tree; // to remove
}

static void matrixToArray( float * tab, const Matrix4d& mat4 )
{
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			tab[ 4*i + j ] = (float)mat4(i,j);
		}
	}
}


static void vect4ToArray( float * tab, const Vector4d& vect )
{
	for( int i =0; i< 3; ++i )
	{
		tab[i] = (float)vect(i);
	}
}

static void vect3ToArray( float * tab, const Vector3& vect )
{
	for( int i =0; i< 3; ++i )
	{
		tab[i] = (float)vect(i);
	}
}

/**
Drawstuff stuff : 
*/

static void DrawJoint( Joint* joint, Matrix4d& currentTransform )
{
	float length = 1.6f;
	//joint->AddToTheta( Pi / 240. );
	
if ( joint->IsEffector() )
{
	//joint->AddToTheta( Pi / 2400. );
}

	//joint->AddToTheta( Pi / 24000. );

//std::cout << Rotx4( joint->GetTheta() ) << std::endl << Translate( joint->GetR() ) << std::endl << Rotx4( joint->GetTheta() ) + Translate( joint->GetR() ) << std::endl;
	
	
	//draw line between positions
	float from[3];
	vect4ToArray( from, currentTransform.col(3) );

	Matrix4d jointTransform = Translate( joint->GetR() ); // translation of current joint
	switch( joint->GetRotation() )
	{
		case X:
			jointTransform = jointTransform + Rotx4( joint->GetTheta() );
			break;
		case Y:
			jointTransform = jointTransform + Roty4( joint->GetTheta() );
			break;
		case Z:
			jointTransform = jointTransform + Rotz4( joint->GetTheta() );
			break;
	}
	//currentTransform = currentTransform * ( Rotz4( joint->GetTheta() ) + Translate( joint->GetR() ) );
	currentTransform = currentTransform * jointTransform;
//std::cout << currentTransform << std::endl;

	float R[12];
	matrixToArray( R, currentTransform );
	//cout << currentTransform << endl;
    dsSetColor(1.0,0.0,0.0);
	float ps[3];
	vect4ToArray( ps, currentTransform.col(3) );
	//= {currentTransform(0,3), currentTransform(1,3), currentTransform(2,3)};
	//double ps[3] = {0,0,0};
	if(joint->pChild_)
	{
		dsDrawSphere (ps, R, 0.05);
	}
	else
	{
		float sides[3] = {0.05, 0.05, 0.05};
		dsDrawBox(ps, R, sides);
	}

	//draw line between positions
	if( joint->pRealparent_ )
		dsDrawLine( from, ps );

 //   dsSetColor(0.0,1.0,0.0);
	//Vector3 pos = joint->GetS();
	//for( int j =0; j< 3; ++j )
	//{
	//	ps[ j ] = float(pos(j));
	//}
	//ps[ 2 ] = ps[ 2 ] + 0.5f;
	//dsDrawSphere (ps, R, 0.05);

	////draw line between positions
	//from[ 2 ] = from[ 2 ] + 0.5f;
	//if( joint->pRealparent_ )
	//	dsDrawLine( from, ps );
}

static void DrawArrow( const Vector3& from, const Vector3& dir )
{
	/*Vector3 dest; GetOGLPos(from.x(), from.y(), dest);
	Vector3 destdir = dest + dir;*/
	
	//glDisable(GL_LIGHTING);
	//glColor3f(1.0f, 1.0f, 0.0f);
	//glLineWidth(4.0);
	//glBegin(GL_LINES);
	//glVertex3f( dest.x(), dest.y(), 1); //dest.z() );
	//glVertex3f( destdir.x(), destdir.y(), destdir.z() );
	//glEnd();
	//glLineWidth(1.0);
	//glEnable(GL_LIGHTING);

	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	
	Vector3 destdir = from+dir;
	float fr[3];
	float t[3];
	vect3ToArray(fr, from); 
	vect3ToArray(t, destdir); 
    dsSetColor(1.0, 1.0, 0.0);
	dsDrawLine  (fr, t );
	dsDrawSphere(t, Identity, 0.02 );


	//ViewOrtho( 200, 200);
	//glDisable(GL_LIGHTING);
	//glColor3f(1.0f, 1.0f, 0.0f);
	//glLineWidth(2.0);
	//glBegin(GL_LINES);
	//glVertex3f( from.x(), from.y(), from.z() );
	//glVertex3f( to.x(), to.y(), to.z() );
	//glEnd();
	//glLineWidth(1.0);
	//glEnable(GL_LIGHTING);
	//
	//ViewPerspective();
/*	glDisable(GL_LIGHTING);
	glColor3f(1.0f, 1.0f, 0.0f);
	glLineWidth(2.0);
	glBegin(GL_LINES);
	glVertex3f( from.x(), from.y(), from.z() );
	glVertex3f( to.x(), to.y(), to.z() );
	glEnd();
	glLineWidth(1.0);
	glEnable(GL_LIGHTING);*/
}

static void DrawTree( Tree* tree )
{
	tree->Compute();
	//joint->AddToTheta( Pi / 240. );
	Matrix4d m =  Matrix4d::Identity();
	//cout << m << endl;
	Joint* joint = tree->GetRoot();
	//joint->AddToTheta( Pi / 2400. );
	while ( joint ) {
		DrawJoint( joint, m );
		joint = ( joint->IsEffector() ? 0 : tree->GetSuccessor( joint ) );
		/*if (joint )
		{
			joint->AddToTheta( Pi / 240. );
		}*/
	}
	
	tree->ComputeJacobian();
	std::cout << " FORCE MANIPULABILITY " << tree->ComputeForceManipulability() << std::endl << std::endl ;
	std::cout << " VELOCITY MANIPULABILITY " << tree->ComputeVelocityManipulability() << std::endl << std::endl << std::endl << std::endl;
}


static void simLoop (int pause)
{
	const Vector3 arrowFrom(0.5, 0, 0.5);
	DrawTree(test);
	std::cout << " DIRECTION " << *(test->direction_) << std::endl;
	DrawArrow(arrowFrom, *(test->direction_) );
}

void start()
{
    static float xyz[3] = {0.0,-3.0,1.0};
    static float hpr[3] = {90.0,0.0,0.0};
    dsSetViewpoint (xyz,hpr);
}



int main(int argc, char *argv[])
{
	Tree treeY;
	//Jacobian *jacobY;
	Joint* joints[5];
	BuildTree(joints,treeY);
	treeY.Init();
	treeY.Compute();
	visitor.Configure( 0.f, 1.f);
				
	//SAMPLE TESTING
	generator->GenerateSamples(*test, 10000);

	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
	fn.command = &command;
    fn.stop    = 0;
    fn.path_to_textures = "./textures";
    dsSimulationLoop (argc,argv,352,288,&fn);

    return 0;
}
