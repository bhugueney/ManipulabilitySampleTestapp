#include "PRM.h"
#include "RobotRootSampler.h"
#include "State.h"

#include <vector>

using namespace roadmap;
using namespace statepostures;

namespace
{
	// breadth-first approach
	void GenerateGraphRec(int& nbTrials, int& nbNodes, const std::vector<int>& indices, const World& world, const StateTree& stateTree, PRM::graph_t& graph)
	{
		--nbTrials;
		if(nbTrials < 0)
		{
			return;
		}
		std::cout << "nb Nodes " << nbNodes << std::endl;
		std::cout << "nb indices " << indices.size() << std::endl;
		std::vector<int> sonindexes;
		if(nbNodes <= 1) return;
		for(std::vector<int>::const_iterator idx = indices.begin(); idx != indices.end(); ++idx)
		{
			std::cout << "indices" << (*idx) << std::endl;
			const Robot* currentRobot = graph.GetNodeContent(*idx);
			State currentState = stateTree.GetState(*currentRobot);
			RobotRootSampler sampler(world, *currentRobot);
			std::cout << "transitions" << currentState.transitions_.size() << std::endl;
			for(State::CIT_Transition it = currentState.transitions_.begin(); it!=currentState.transitions_.end() && nbNodes > 0; ++it)
			{
				int dafuq = it->second;
			std::cout << "BEFORE SAMPLE " << (*idx) << "   " << (it->second) << std::endl;
				Robot * res = sampler.GenerateSampleAndContact(it->second);
			std::cout << "AFTER SAMPLE " << (*idx) << std::endl;
				if(res)
				{
					int newId = graph.AddNode(res);
					if(newId >= 0)
					{
						--nbNodes;
						std::cout << "Node added " << nbNodes << std::endl;
						graph.AddEdge(*idx, newId);
						sonindexes.push_back(newId);
					}
					else
					{
						--nbNodes;
						std::cout << "all added " << nbNodes << std::endl;
						return;
					}
				}
			}
		}
		if(indices.size())
			GenerateGraphRec(nbTrials, nbNodes, sonindexes, world, stateTree, graph);
	}

	PRM::graph_t* GenerateGraph(const int nbNodes, const Robot& startConfiguration, const World& world, const StateTree& stateTree)
	{
		PRM::graph_t* graph = new PRM::graph_t();
		int remainingSteps = nbNodes;
		int nbTrials = 100000;
		Robot* firstRobot = startConfiguration.Clone();
		std::vector<int> init; init.push_back(graph->AddNode(firstRobot));
		GenerateGraphRec(nbTrials, remainingSteps, init, world, stateTree, *graph);
		return graph;
	}
	
	float Distance(const Robot* a, const Robot* b)
	{
		// TODO return distance a.root, b.root
		return 1.f;
	}

}

PRM::PRM(const int nbNodes, const Robot& startConfiguration, const World& world, const StateTree& stateTree)
	: graph_(GenerateGraph(nbNodes, startConfiguration, world, stateTree))
{
	// NOTHING
}

PRM::~PRM()
{
	delete graph_;
}
