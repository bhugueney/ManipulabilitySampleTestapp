#include "kinematic/Tree.h"
#include "kinematic/MatrixDefs.h"

#include "kinematic/Pi.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;


#include <iostream>

using namespace std;

#define RADIAN(X)	((X)*RadiansToDegrees)

using namespace matrices;
using namespace Eigen;

Tree* test; // TO F... REMOVE

void BuildTree(Joint *node[], Tree &tree)
{
	const Vector3 unitx(1, 0, 0);
	const Vector3 unity(0, 1, 0);
	const Vector3 unitz(0, 0, 1);
	const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
	const Vector3 zero(0,0,0);

	//node[0] = new Joint(Vector3(0.0f, -0.5f, 0.0f), unit1,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	node[0] = new Joint(Vector3(0.0, -0.5, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	tree.InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, 0.4, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	tree.InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, 1.2, 0.0), zero,EFFECTOR);
	tree.InsertChild(node[1], node[2]);
	test = &tree; // to remove
}




/**
Drawstuff stuff : 
*/

static void DrawJoint( Joint* joint, Matrix4d& currentTransform )
{
	float length = 1.6;
	//joint->AddToTheta( Pi / 240. );
	
if ( joint->IsEffector() )
{
	//joint->AddToTheta( Pi / 2400. );
}

	//joint->AddToTheta( Pi / 24000. );

//std::cout << Rotx4( joint->GetTheta() ) << std::endl << Translate( joint->GetR() ) << std::endl << Rotx4( joint->GetTheta() ) + Translate( joint->GetR() ) << std::endl;
	currentTransform = currentTransform * ( Rotz4( joint->GetTheta() ) + Translate( joint->GetR() ) );
	//std::cout << currentTransform << std::endl;
	double R[12];
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			int k =  4*i + j;
			R[ k ] = currentTransform(i,j);
		}
	}
	//cout << currentTransform << endl;
    dsSetColor(1.0,0.0,0.0);
	Vector3 pos = joint->GetS();
	double ps[3] = {currentTransform(0,3), currentTransform(1,3), currentTransform(2,3)};
	//double ps[3] = {0,0,0};
	dsDrawSphereD (ps, R, 0.1);

    dsSetColor(0.0,1.0,0.0);
	for( int j =0; j< 3; ++j )
	{
		ps[ j ] = pos(j);
	}
	ps[ 2 ] = ps[ 2 ] + 0.5;
	dsDrawSphereD (ps, R, 0.1);
}


static void DrawTree( Tree* tree )
{
	tree->Compute();
	//joint->AddToTheta( Pi / 240. );
	Matrix4d m =  Matrix4d::Identity();
	//cout << m << endl;
	Joint* joint = tree->GetRoot();
	joint->AddToTheta( Pi / 2400. );
	while ( joint ) {
		DrawJoint( joint, m );
		joint = ( joint->IsEffector() ? 0 : tree->GetSuccessor( joint ) );
		if (joint )
		{
			joint->AddToTheta( Pi / 240. );
		}
	}
}


static void simLoop (int pause)
{
	DrawTree(test);
	/*Matrix4d m = Matrix4d::Identity();
	dsSetColor(1.0,0.0,0.0);
	m = Rotx4(Pi / 2);
	std::cout << m << std::endl;
	double R[12];
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			int k =  4*i + j;
			R[ k ] = m(i,j);
		}
	}
	double ps[3] = {1, 1, 0};
	dsDrawCapsuleD (ps, R, 1, 0.1);*/

	/*dsSetColor(0.0,0.0,1.0);
	m = Rotz4(Pi / 2);
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			int k =  4*i + j;
			R[ k ] = m(i,j);
		}
	}
	dsDrawCapsuleD (ps, R, 1.6, 0.1);

	dsSetColor(0.0,1.0,0.0);
	m = Roty4(Pi / 2);;
	for( int i =0; i< 3; ++i )
	{
		for( int j =0; j< 4; ++j )
		{
			int k =  4*i + j;
			R[ k ] = m(i,j);
		}
	}
	dsDrawCapsuleD (ps, R, 1.6, 0.1);*/

}

void start()
{
    static float xyz[3] = {0.0,-3.0,1.0};
    static float hpr[3] = {90.0,0.0,0.0};
    dsSetViewpoint (xyz,hpr);
}



int main(int argc, char *argv[])
{
	Tree treeY;
	//Jacobian *jacobY;
	Joint* joints[3];
	BuildTree(joints,treeY);
	treeY.Init();
	treeY.Compute();
	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
    fn.command = 0;
    fn.stop    = 0;
    fn.path_to_textures = "./textures";
    dsSimulationLoop (argc,argv,352,288,&fn);

    return 0;
}
