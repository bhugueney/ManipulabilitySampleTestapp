
#include "SupportPolygon.h"
#include "SupportPolygonVisitor_ABC.h"
#include "Robot.h"
#include "Tree.h"

#include "World.h"

#include<Eigen/StdVector>

using namespace matrices;
using namespace Eigen;

using namespace std;

struct SupportPolygonPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	SupportPolygonPImpl(const Robot& robot)
	{
		const Robot::T_Tree& trees = robot.GetTrees();
		for(Robot::T_TreeCIT it = trees.begin(); it!= trees.end(); ++it)
		{
			if((*it)->IsLocked())
			{
				points_.push_back((*it)->GetEffectorPosition(0));
			}
		}
		if(points_.size() > 2) // add last point only if already have a polygon
		{
			points_ = ConvexHull(points_);
			//points_.push_back(points_[0]);
			//compute ConvexHull
			//points_ = ConvexHull(points_);
		}
	}

	~SupportPolygonPImpl()
	{
		// NOTHING
	}


	typedef std::vector<matrices::Vector3,Eigen::aligned_allocator<matrices::Vector3>> T_Point;
	
	// isLeft(): tests if a point is Left|On|Right of an infinite line.
	//    Input:  three points P0, P1, and P2
	//    Return: >0 for P2 left of the line through P0 and P1
	//            =0 for P2 on the line
	//            <0 for P2 right of the line
	//    See: the January 2001 Algorithm "Area of 2D and 3D Triangles and Polygons"
	NUMBER isLeft( const Vector3& P0, const Vector3& P1, const Vector3& P2 )
	{
		return ( (P1.x() - P0.x()) * (P2.y() - P0.y())
				- (P2.x() - P0.x()) * (P1.y() - P0.y()) );
	}

	// source http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm#wn_PinPolygon()
	// wn_PnPoly(): winding number test for a Vector3 in a polygon
	//      Input:   P = a Vector3,
	//               points_ = Point vector of size n+1 with points_[n]=points_[0]
	//      Return:  wn = the winding number (=0 only if P is outside points_[])
	bool InPolygon ( const T_Point& points, const Vector3& P )
	{
		int    wn = 0;    // the winding number counter
		int n = points.size() - 1;
		if(n < 0)
		{
			return false;
		}
		else if(n == 0)
		{
			return( points[0] == P);
		}
		else if(n == 1)
		{
			return (isLeft(points[0], points[1], P) == 0);
		}

		// loop through all edges of the polygon
		for (int i=0; i<n; i++) 
		{   // edge from points_[i] to points_[i+1]
			if (points[i].y() <= P.y()) 
			{   // start y <= P.y()
				if (points[i+1].y() > P.y())      // an upward crossing
				{
					if (isLeft( points[i], points[i+1], P) > 0)  // P left of edge
						++wn;            // have a valid up intersect
				}
			}
			else 
			{   // start y > P.y() (no test needed)
				if (points[i+1].y() <= P.y())     // a downward crossing
				{
					if (isLeft( points[i], points[i+1], P) < 0)  // P right of edge
						--wn;            // have a valid down intersect
				}
			}
		}
		return !( wn == 0 );
	}

	const Vector3& LeftMost(const T_Point& points)
	{
		unsigned int i = 0;
		for(unsigned int j = 1; j < points.size(); ++j)
		{
			if(points[j].x() < points[i].x())
			{
				i = j;
			}
		}
		return points[i];
	}

	//http://en.wikipedia.org/wiki/Gift_wrapping_algorithm
	T_Point ConvexHull(const T_Point& points)
	{
		T_Point res;
		Vector3 pointOnHull = LeftMost(points);	
		Vector3 endPoint;
		do
		{
			Vector3 pi = pointOnHull;
			endPoint = points[0];
			for(unsigned int j = 1; j < points.size(); ++j)
			{
				if((endPoint == pointOnHull) || (isLeft(pi, endPoint, points[j]) > 0))
				{
					endPoint = points[j];
				}
			}
			res.push_back(pi);
			pointOnHull = endPoint;
		} while(endPoint != res[0]);
		res.push_back(endPoint);
		return res;
	}

	T_Point points_;
};

SupportPolygon::SupportPolygon(const Robot& robot)
	: pImpl_(new SupportPolygonPImpl(robot))
{
	//TODO
}

SupportPolygon::~SupportPolygon()
{
	// NOTHING
}

void SupportPolygon::Accept(SupportPolygonVisitor_ABC* visitor) const
{
	for(SupportPolygonPImpl::T_Point::const_iterator it=pImpl_->points_.begin(); it != pImpl_->points_.end(); ++it)
	{
		visitor->Visit(*it);
	}
}


bool SupportPolygon::Contains(const matrices::Vector3& aPoint) const
{
	return pImpl_->InPolygon(pImpl_->points_, aPoint);
}

bool SupportPolygon::WouldContain(const matrices::Vector3& aPoint, const matrices::Vector3& polygonPoint)
{
	/*SupportPolygonPImpl::T_Point points = pImpl_->points_;
	if (points.size() > 0 )
	{
		if (points.size() > 2)
		{
			points.pop_back();
		}
		points.push_back(polygonPoint);
		points = pImpl_->ConvexHull(points);
	}
	return pImpl_->InPolygon(points, aPoint);*/
	return true;
}


bool SupportPolygon::WouldContain(const matrices::Vector3& aPoint, const Robot& robot, const Tree& tree)
{
	// TODO
	/*SupportPolygonPImpl::T_Point points = pImpl_->points_;
	if (points.size() > 0 )
	{
		if (points.size() > 2)
		{
			points.pop_back();
		}
		points.push_back(tree.GetPosition());
		points = pImpl_->ConvexHull(points);
	}
	return pImpl_->InPolygon(points, aPoint);*/
	return true;
}


