
#include "SampleGenerator.h"
#include "SampleGeneratorVisitor_ABC.h"
#include "Sample.h"
#include "Tree.h"
#include "Robot.h"
#include "Joint.h"
#include "Pi.h"
#include "MatrixDefs.h"
#include "Filter_ABC.h"

#include <vector>
#include <math.h>
#include "time.h"

using namespace matrices;
using namespace std;


namespace
{

typedef std::vector<NUMBER> TJointsValues;
typedef TJointsValues::const_iterator TJointsValues_CIT;
typedef std::vector<TJointsValues> AllJoints;
typedef AllJoints::const_iterator ALLJoint_CIT;

//http://fr.wikipedia.org/wiki/Calcul_de_la_racine_%C3%A9ni%C3%A8me_d'un_nombre
// compute squareRoot n of a number
NUMBER nsqrt(NUMBER a, unsigned int n)
{
	return exp((1.f / n) * log(a));
}

void CartesianProduct(AllJoints& allValues, const TJointsValues& values)
{
	AllJoints res;
	for(ALLJoint_CIT it = allValues.begin(); it != allValues.end(); ++it)
	{
		for(TJointsValues_CIT it2 = values.begin(); it2 != values.end(); ++it2)
		{
			TJointsValues tmp = (*it);
			tmp.push_back(*it2);
			res.push_back(tmp);
		}	
	}
	allValues = res;
}

AllJoints CartesianProduct(AllJoints& allValues)
{
	AllJoints res;
	ALLJoint_CIT it = allValues.begin();
	if(it!= allValues.end())
	{
		for(TJointsValues_CIT it2 = (*it).begin(); it2 != (*it).end(); ++it2)
		{
			TJointsValues tmp; tmp.push_back(*it2);
			res.push_back(tmp);
		}
		++it;
		for(; it != allValues.end(); ++it)
		{
			CartesianProduct(res,(*it));
		}
	}
	return res;
}

void GenerateJointAngles(Joint* joint, int nbSamples, TJointsValues& jointValues)
{
	NUMBER interval = (joint->GetMaxTheta() - joint->GetMinTheta()) / nbSamples;
	for (int i =0; i < nbSamples - 1; ++ i)
	{
		jointValues.push_back(joint->GetMinTheta() + i * interval);
	}
	jointValues.push_back(joint->GetMaxTheta());
}

}

struct PImpl
{
	PImpl()
	{
		// NOTHING
	}

	~PImpl()
	{
		// NOTHING
	}
	
	typedef std::vector<Sample> LSamples;
	typedef std::vector<LSamples> LLSamples;
	typedef LSamples::const_iterator CITLSamples;
	typedef LSamples::iterator ITLSamples;

	void GenerateSample(LSamples& samples, Tree& tree, int nbSamples, int samplesPerJoint)
	{
		AllJoints joints;
		Joint* j = tree.GetRoot();
		while(j)
		{
			TJointsValues values;
			GenerateJointAngles(j, samplesPerJoint, values);
			joints.push_back(values);
			j = j->pChild_;
		}

		AllJoints samplesJointValues = CartesianProduct(joints);
		for(ALLJoint_CIT it = samplesJointValues.begin(); it != samplesJointValues.end(); ++it)
		{
			j = tree.GetRoot();
			for(TJointsValues_CIT it2 = (*it).begin(); it2 != (*it).end(); ++it2)
			{
				j->SetTheta(*it2);
				j = j->pChild_;
			}
			tree.Compute();tree.ComputeJacobian();
			samples.push_back(Sample(tree));
		}
	}
	LLSamples allSamples_;
};

SampleGenerator *SampleGenerator::instance = 0;

SampleGenerator::SampleGenerator()
	: pImpl_(new PImpl)
{
	srand((unsigned int)(time(0))); //Init Random generation
}

SampleGenerator::~SampleGenerator()
{
	// NOTHING
}


void SampleGenerator::GenerateSamples(Tree& tree, int nbSamples)
{
	assert(nbSamples > 0);
	NUMBER samplesPerJoint = nsqrt(nbSamples, tree.GetNumJoint());
	PImpl::LSamples samples;
	Tree::TREE_ID id = tree.GetTemplateId();
	if(pImpl_->allSamples_.size() == id) // TODO this sucks, entries have to be created in sequential order
	{
		pImpl_->allSamples_.push_back(samples);
		Sample init(tree);
		//pImpl_->Reset();
		pImpl_->GenerateSample(pImpl_->allSamples_[id], tree, nbSamples, (int)samplesPerJoint);
		init.LoadIntoTree(tree);
	}
}

void SampleGenerator::GenerateSamples(Robot& robot, int nbSamples)
{
	for(unsigned int i = 0; i < robot.GetNumTrees(); ++i)
	{
		GenerateSamples(*(robot.GetTree(i)), nbSamples);
	}
}

void SampleGenerator::Request(const Tree& tree, SampleGeneratorVisitor_ABC& visitor, const Filter_ABC& filter) const
{
	for(PImpl::ITLSamples it = pImpl_->allSamples_[tree.GetTemplateId()].begin(); it != pImpl_->allSamples_[tree.GetTemplateId()].end(); ++it)
	{
		if(filter.ApplyFilter(*it))
			visitor.Visit(tree, *it);
	}
}


void SampleGenerator::Request(const Tree& tree, SampleGeneratorVisitor_ABC& visitor) const
{
	for(PImpl::ITLSamples it = pImpl_->allSamples_[tree.GetTemplateId()].begin(); it != pImpl_->allSamples_[tree.GetTemplateId()].end(); ++it)
	{
			visitor.Visit(tree, *it);
	}
}

