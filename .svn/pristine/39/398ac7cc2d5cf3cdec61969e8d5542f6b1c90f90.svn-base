
#include "DrawRobot.h"
#include "DrawTree.h"
//#include "DrawSupportPolygon.h"

#include "API/RobotI.h"
#include "API/TreeI.h"

#include "MatrixDefs.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#include <vector>

using namespace std;
using namespace matrices;
using namespace manip_core;

struct PImpl
{
	PImpl(const RobotI* robot)
		:robot_(robot)
		,drawSupport_(false)
	{
		//NOTHING
	}

	~PImpl()
	{
		//NOTHING
	}

	const RobotI* robot_;

	typedef vector<DrawTree> T_Tree;
	typedef T_Tree::iterator T_TreeIT;
	typedef T_Tree::const_iterator T_TreeCIT;
	T_Tree drawTrees_;
	bool drawSupport_;
};



//TODO listener in case of adding new trees
DrawRobot::DrawRobot(const RobotI* robot)
	: pImpl_(new PImpl(robot))
{
	const TreeI* trunk = robot->GetTorsoI();

	if(trunk)
	{
		pImpl_->drawTrees_.push_back(DrawTree(trunk, 0.04f, 0.25f));
	}
	int nTrees = robot->GetNumTrees();
	double vect[3];
	for(int i=0; i < nTrees; ++i)
	{
		const TreeI* pTree = robot->GetTreeI(i);
		robot->GetTreeAttach(i, vect);
		pImpl_->drawTrees_.push_back(DrawTree(pTree, vect));
	}
	/*robot.Accept(*this);
	const Tree* trunk = robot.GetTorso();
	if(trunk)
	{
		pImpl_->drawTrees_.push_back(DrawTree(*trunk));
	}*/
}

DrawRobot::~DrawRobot()
{
	// TODO
}

void DrawRobot::ToggleSupportPolygon(bool onoff)
{
	pImpl_->drawSupport_ = onoff;
}

const manip_core::RobotI* DrawRobot::GetRobot()
{
	return pImpl_->robot_;
}


void DrawRobot::Draw() const
{
	dsSetTexture(1);
	double currentTransform[16];
	pImpl_->robot_->ToWorldCoordinates(currentTransform);
	Matrix4 transform;
	matrices::array16ToMatrix4(currentTransform, transform);
	for(PImpl::T_TreeCIT it = pImpl_->drawTrees_.begin(); it!= pImpl_->drawTrees_.end(); ++it)
	{
		it->Draw(transform);
	}
	dsSetTexture(0);

	//if(pImpl_->drawSupport_)
	//{
	//	Vector3 com = matrices::matrix4TimesVect3( pImpl_->robot_->ToWorldCoordinates(), pImpl_->robot_->ComputeCom());
	////Vector3 com = pRobot->ComputeCom();
	//	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	//	float t[3];
	//	t[0] = (float)(com(0));
	//	t[1] = (float)(com(1));
	//	t[2] = (float)(com(2));
	//	dsDrawSphere(t, Identity, 0.1f);
	//	SupportPolygon sp(*pImpl_->robot_);
	//	DrawSupportPolygon dsp(*pImpl_->robot_, sp);
	//	dsp.Draw();
	//}
}

void DrawRobot::DrawNoTexture() const
{
	dsSetTexture(0);
	double currentTransform[16];
	pImpl_->robot_->ToWorldCoordinates(currentTransform);
	Matrix4 transform;
	matrices::array16ToMatrix4(currentTransform, transform);
	for(PImpl::T_TreeCIT it = pImpl_->drawTrees_.begin(); it!= pImpl_->drawTrees_.end(); ++it)
	{
		it->DrawNoTexture(transform);
	}
	dsSetTexture(0);

	//if(pImpl_->drawSupport_)
	//{
	//	Vector3 com = matrices::matrix4TimesVect3( pImpl_->robot_->ToWorldCoordinates(), pImpl_->robot_->ComputeCom());
	////Vector3 com = pRobot->ComputeCom();
	//	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	//	float t[3];
	//	t[0] = (float)(com(0));
	//	t[1] = (float)(com(1));
	//	t[2] = (float)(com(2));
	//	dsDrawSphere(t, Identity, 0.1f);
	//	SupportPolygon sp(*pImpl_->robot_);
	//	DrawSupportPolygon dsp(*pImpl_->robot_, sp);
	//	dsp.Draw();
	//}
}

//void DrawRobot::Visit(const Tree& tree, const Joint* anchor)
//{
//	pImpl_->drawTrees_.push_back(DrawTree(tree));
//}

