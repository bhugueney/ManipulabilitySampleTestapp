
#include "Robot.h"
#include "RobotVisitor_ABC.h"
#include "Tree.h"

#include "IKSolver.h"

#include <vector>

using namespace matrices;
using namespace Eigen;

using namespace std;

struct RobotPImpl
{
	EIGEN_MAKE_ALIGNED_OPERATOR_NEW
	RobotPImpl(const Matrix4& transform)
	{
		toWorldCoo_ = transform;
		toRobotCoo_ = transform.inverse();
	}

	~RobotPImpl()
	{
		for( T_TreeIT it = trees_.begin(); it!= trees_.end(); ++it)
		{
			delete(*it);
		}
	}

	IKSolver ikSolver_;
	Matrix4 toRobotCoo_;
	Matrix4 toWorldCoo_;

	typedef vector<Tree*> T_Tree;
	typedef T_Tree::iterator T_TreeIT;
	typedef T_Tree::const_iterator T_TreeCIT;
	T_Tree trees_;
};

Robot::Robot(const Matrix4& transform)
	: pImpl_(new RobotPImpl(transform))

{
	// NOTHING
}

Robot::~Robot()
{
	// NOTHING
}

void Robot::Accept(RobotVisitor_ABC& visitor) const
{
	for( RobotPImpl::T_TreeCIT it = pImpl_->trees_.begin(); it!= pImpl_->trees_.end(); ++it)
	{
		visitor.Visit(*(*it));
	}
}

const Matrix4& Robot::ToWorldCoordinates() const
{
	return pImpl_->toWorldCoo_;
}


void Robot::AddTree( Tree* tree )
{
	assert(tree);
	tree->Init();
	tree->ToRest();
	tree->Compute();
	tree->directionForce_ = new Vector3(0,0,1);
	tree->directionVel_ = new Vector3(1,0,0);

	pImpl_->trees_.push_back(tree);
}

void Robot::Move( const matrices::Vector3& direction )
{
	//TODO
}


