#include "kinematic/Joint.h"
#include "kinematic/Tree.h"
#include "kinematic/RobotFactory.h"
#include "kinematic/Robot.h"
#include "kinematic/SupportPolygon.h"

#include "Obstacle.h"
#include "World.h"
#include "kinematic/SampleGenerator.h"
#include "PostureSolver.h"

#include "MatrixDefs.h"
#include "Pi.h"

#include "DrawPostures.h"
#include "DrawRobot.h"
#include "DrawWorld.h"
#include "DrawSupportPolygon.h"

#include "Trajectory.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#ifdef WIN32
#include <windows.h>
#endif

#include <iostream>
#include <vector>


using namespace matrices;
using namespace Eigen;
using namespace std;

// main object
DrawPostures* pDrawPosturesTEST;


Robot* pRobot;
DrawRobot* pDrawRobot;
World* pWorld;
DrawWorld* pDrawWorld;

//Direction of robot movement
Vector3* pDirection;

//basis for arrow drawing
const Vector3 from(0.5, 0, 0.5);

//camera
static float xyz[3] = {-10.0,1,2.0};
static float hpr[3] = {0.0,0.0,0.0};

static bool handleDirection(int cmd)
{
	bool found = false;
	switch (cmd)
		{
		case 'o':
			found = true;
			pDirection = new Vector3(0,0,1);
			break;
		case 'l':
			found = true;
			pDirection = new Vector3(0,0,-1);
			break;
		case 'm':
			found = true;
			pDirection = new Vector3(1,0,0);
			break;
		case 'k':
			found = true;
			pDirection = new Vector3(-1,0,0);
			break;
		case 'i':
			found = true;
			pDirection = new Vector3(0,1,0);
			break;
		case 'p':
			found = true;
			pDirection = new Vector3(0,-1,0);
			break;
		}
	return found;
}

void command(int cmd)   /**  key control function; */
{
	if (!handleDirection(cmd))
	{
		Vector3 trX(0.01, 0, 0);
		Vector3 trY(0,0.01,  0);
		switch (cmd)
		{			
		case 't' :
			pRobot->Reset();
		break;
		case 'r' :
			pRobot->Rest();
		break;
		case 'z' :
			xyz[0] += 0.01f;
			pRobot->Translate(trX);
		dsSetViewpoint (xyz,hpr);
		break;
		case 's' :
			xyz[0] -= 0.01f;
			pRobot->Translate(-trX);
		dsSetViewpoint (xyz,hpr);
		break;
		case 'q' :
			xyz[1] += 0.01f;
			pRobot->Translate(trY);
		dsSetViewpoint (xyz,hpr);
		break;
		case 'd' :
			xyz[1] -= 0.01f;
			pRobot->Translate(-trY);
		dsSetViewpoint (xyz,hpr);
		break;
		}
	}
}


void BuildWorld(World& world)
{
	// FORWARD OBSTACLES
	/*Vector3 p1(-1,1,0.1f);
	Vector3 p2(1,1,0.1f);
	Vector3 p3(1,0,0.1f);
	Vector3 p4(-1,0,0.1f);*/

	Vector3 p1(-10,10,0.4f);
	Vector3 p2(10,10,0.4f);
	Vector3 p3(10,-10,0.4f);
	Vector3 p4(-10,-10,0.4f);

	world.AddObstacle(new Obstacle(p1,p2,p3,p4));

	NUMBER pose = -0.f;
	NUMBER posey = -5.f;
	Vector3 p11(pose,posey+ 10,1.f);
	Vector3 p12(pose+10,posey+ 10,1.f);
	Vector3 p13(pose+10,posey,1.f);
	Vector3 p14(pose,posey,1.f);

	world.AddObstacle(new Obstacle(p11,p12,p13,p14));

	//pose = -3.f;
	//posey = -0.5f;
	//Vector3 p111(pose,posey,1.f);
	//Vector3 p121(pose+1,posey,1.f);
	//Vector3 p131(pose+1,posey,0.5f);
	//Vector3 p141(pose,posey,0.5f);

	//world.AddObstacle(new Obstacle(p111,p121,p131,p141));

	//pose = 0.5f;
	//posey = 1.f;
	//Vector3 p21(pose,posey+ 1,0.4f);
	//Vector3 p22(pose+1,posey+ 1,0.4f);
	//Vector3 p23(pose+1,posey,1.f);
	//Vector3 p24(pose,posey,1.f);

	//world.AddObstacle(new Obstacle(p21,p22,p23,p24));

	//pose = -6.f;
	//posey = 3.f;
	//// LEFT OBSTACLES
	//Vector3 pl1(pose,posey,1.f);
	//Vector3 pl2(pose,posey+1,1.f);
	//Vector3 pl3(pose,posey+1,0.1f);
	//Vector3 pl4(pose,posey,0.1f);

	//world.AddObstacle(new Obstacle(pl1,pl2,pl3,pl4));

	//pose = -5.f;
	//posey = 3.f;
	//Vector3 pla(pose,posey+ 1,0.5f);
	//Vector3 pla2(pose+1,posey+ 1,0.5f);
	//Vector3 pla3(pose+1,posey,0.1f);
	//Vector3 pla4(pose,posey,0.1f);
}

/**
Drawstuff stuff :
*/
static void DrawArrow(const Vector3& from, const Vector3& dir)
{
	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	
	Vector3 destdir = from+dir;
	float fr[3];
	float t[3];
	vect3ToArray(fr, from); 
	vect3ToArray(t, destdir); 
	dsDrawLine  (fr, t);
	dsDrawSphere(t, Identity, 0.02f);
}


static void simLoop (int pause)
{
	pRobot->Move(*pDirection, *pWorld);
	pDrawRobot->Draw();
	pDrawWorld->Draw();
	DrawArrow(from, *pDirection);
/*TEST*/
	Vector3 com = matrices::matrix4TimesVect3( pRobot->ToWorldCoordinates(), pRobot->ComputeCom());
	//Vector3 com = pRobot->ComputeCom();
float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
float t[3];
t[0] = (float)(com(0));
t[1] = (float)(com(1));
t[2] = (float)(com(2));
dsDrawSphere(t, Identity, 0.1f);
pDrawPosturesTEST->Draw();
SupportPolygon sup(*pRobot);
DrawSupportPolygon dsup(*pRobot, sup);
dsup.Draw();
/*TEST*/
}

void start()
{
    dsSetViewpoint (xyz,hpr);
}

int main(int argc, char *argv[])
{
	//init robot
	Matrix4 robotBasis(MatrixX::Identity(4,4));
	//robotBasis(0,3) = -7;

	factories::RobotFactory robotfact_;
	pRobot = robotfact_.CreateRobot(factories::Human, robotBasis);

	//init DrawRobot
	DrawRobot dRobot(*pRobot);
	pDrawRobot = &dRobot;

	// for now mostly contains obstacles
	World world;
	BuildWorld(world);
	pWorld = &world;

	//init DrawWorld
	DrawWorld dWorld(world);
	pDrawWorld = &dWorld;

	//movement direction
	Vector3 direction(1,0,0);
	pDirection = &direction;


/* TEST */
SampleGenerator* sg = SampleGenerator::GetInstance();
sg->GenerateSamples(*pRobot,1000);
PostureSolver ps(world);
Matrix4 robotBasis2(MatrixX::Identity(4,4));
Trajectory traj;

/* trajectory */
robotBasis2(0,3) = -6 * 0.7;
traj.AddCheckPoint( 0, robotBasis2);

robotBasis2(0,3) = -4 * 0.7;
traj.AddCheckPoint( 1, robotBasis2);

robotBasis2(0,3) = -3 * 0.7;
traj.AddCheckPoint( 2, robotBasis2);

robotBasis2(0,3) = -1 * 0.7;
traj.AddCheckPoint( 3, robotBasis2);

robotBasis2(0,3) = -0.2;
robotBasis2(2,3) = 0.4;
traj.AddCheckPoint( 4, robotBasis2);

robotBasis2(2,3) = 0.7;
robotBasis2(0,3) =  0.7 - 0.4;
traj.AddCheckPoint( 5, robotBasis2);

robotBasis2(0,3) = 2 * 0.7 - 0.4;
traj.AddCheckPoint( 6, robotBasis2);
/* trajectory */

pDrawPosturesTEST = new DrawPostures(ps);
ps.CreatePostures(*pRobot, traj);
/*TEST */

	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
	fn.command = &command;
    fn.stop    = 0;
    fn.path_to_textures = "./textures";
    dsSimulationLoop (argc,argv,800,600,&fn);

    return 0;
}
