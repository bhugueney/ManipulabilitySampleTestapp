
#include "Intersection.h"

#include "Obstacle.h"

#include "kinematic/Tree.h"
#include "kinematic/Robot.h"

#include <math.h>

using namespace matrices;
using namespace Eigen;

Intersection::Intersection()
{
	// NOTHING
}

Intersection::~Intersection()
{
	// NOTHING
}

float Intersection::determinant(const Vector2& A, const Vector2& B, const Vector2& C) const
{
	// xA * yB + yA * xC  + xB * yC - xA * yC - yA * xB - yB * xC
	return (float)( A.x() * B.y() + A.y() * C.x()  + B.x() * C.y() - A.x() * C.y() - A.y() * B.x() - B.y() * C.x());
}

void lineEq( const Vector2& A, const Vector2& B, double& a, double& b)
{
	a = ( A.y() - B.y() ) / ( A.x() - B.x() );
	b = A.y() - a * A.x();
}

bool Intersection::IntersectSegments( const Vector2& A, const Vector2& B, const Vector2& C, const Vector2& D, Vector3& intersectionPoint ) const
{
	// http://www.ilemaths.net/forum-sujet-30008.html#msg138234
	// improvement : bentley-ottmann Algorithm
	
	// C and D on each side of A B 
	if ((determinant( A, B, C ) * determinant( A, B, D ) < 0) && (determinant( C, D, A ) * determinant( C, D, B ) < 0))
	{
		double xInt, yInt;
		const float treshold = 0.001f;
		double a, b, c, d;
		// we need to handle case where equation of type x = a
		if( abs( A.x() - B.x() ) < treshold ) // since intersection, AB and CD not // so this can happen just once
		{
			lineEq( C, D, c, d );
			xInt = A.x();
			yInt = c * xInt + d;
		}
		else if( abs( C.x() - D.x() ) < treshold )
		{
			// line AB y = ax + b
			lineEq( A, B, a, b );
			xInt = C.x();
			yInt = a * xInt + b;
		}
		else
		{
			lineEq( A, B, a, b );
			lineEq( C, D, c, d );
			xInt = ( d - b ) / ( a - c );
			yInt = c * xInt + d;
		}
		intersectionPoint(0) = xInt;
		intersectionPoint(1) = yInt ;
		intersectionPoint(2) = 0 ;
		return true;
	}
	return false;
}

bool Intersection::Intersect(const Tree& tree, const Vector3& target ) const
{
	//TODO : first implemen only checks distance...
	float bRad = tree.GetBoundaryRadius(); //TODO reduction factor
	return (target - tree.GetPosition() ).norm() < bRad;
}

//TODO : affiner intersection avec joint limits
bool Intersection::Intersect(const Robot& robot, const Tree& tree, const Obstacle& obstacle, Vector3& anInterPoint ) const
{
	
	//only considering obstacles in front of us = x positive in robot coordinates
	if( (matrix4TimesVect3( robot.ToRobotCoordinates(), obstacle.Center()).x() < 0 ) )
	{
		return false;
	}

	//applying robot transformation for tree
	Vector3 treePositionWorld = matrix4TimesVect3( robot.ToWorldCoordinates(), tree.GetPosition() );
	
	// get center of the circle 
	Vector3 center(0,0,0);
	float distance = obstacle.Distance( treePositionWorld, center );
	Vector3 cv = treePositionWorld - center;
	Vector3 ov = obstacle.Center() - center;
	
	float w, h;
	w = obstacle.GetW(); h = obstacle.GetH();
	// http://homeomath.imingo.net/sphere2.htm
	// use this ? http://stackoverflow.com/a/402010
	float bRad = tree.GetBoundaryRadius();
	if ( distance < bRad ) // obstacle plan in range
	{
		// go into rectangle plan to check what we want
		//float circleRadius = sqrt( bRad * bRad -  obstacle.GetD() * obstacle.GetD() );
		float circleRadius = sqrt( bRad * bRad -  distance * distance );
		Vector3 centerR = matrix4TimesVect3(obstacle.BasisInv(), center);

		double xc, yc;
		xc = centerR(0); yc = centerR(1);
		if( ( xc >= 0 && xc <= w ) && ( yc >= 0 && yc <= h ) ) // is center inside obstacle ? -> take center
		{
			anInterPoint = center;
			return true;
		}
		//
		float mRad = circleRadius * 0.8f;
		if( ( xc + mRad > 0 && xc - mRad < w ) && ( yc + mRad > 0 && yc - mRad < h ) ) // on a border -> intersects one side
		{
			Vector2 center2( xc, yc);
			Vector2 centerRectangle( ( w / 2 ), ( h / 2 ));
			Vector3 intersectionPoint;
			// Comparing each segment
			//ABCD clockwise from upperLeft
			Vector2 A(0,h);
			Vector2 B(w,h);
			Vector2 C(w,0);
			Vector2 D(0,0);

			bool ok = true;
			if( ! IntersectSegments( center2, centerRectangle, A, B, intersectionPoint) )
			{
				if( ! IntersectSegments( center2, centerRectangle, A, D, intersectionPoint) )
				{
					if( ! IntersectSegments( center2, centerRectangle, B, C, intersectionPoint) )
					{
						ok = IntersectSegments( center2, centerRectangle, C, D, intersectionPoint);
					}
				}
			}
			if( ok )
			{
				// eq de la droite entre les 2 centres
				anInterPoint = matrix4TimesVect3(obstacle.Basis(), intersectionPoint);
				return true;
			}
		}

	}
	return false;
}
