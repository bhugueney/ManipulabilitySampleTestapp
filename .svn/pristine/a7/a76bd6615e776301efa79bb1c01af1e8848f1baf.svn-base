
#include "IKSolver.h"
#include "Tree.h"

#include <iostream>

using namespace matrices;
using namespace Eigen;

IKSolver::IKSolver( const float stepSize, const float treshold )
: stepSize_(stepSize)
, treshold_(treshold)
{
	// NOTHING
}

IKSolver::~IKSolver()
{
	// NOTHING
}

bool IKSolver::Step( Tree& tree, const Vector3& target ) // game programming gems 4 2.6
{
	std::cout << " DAFUQ " << std::endl << target << std::endl;

	Vector3 dist = tree.GetEffectorPosition(tree.GetNumEffector()-1) - target; //TODO we only have one effector  so weird huh ?
	std::cout << " DAFUQ " << std::endl << dist << std::endl;
	if( dist.norm() < treshold_) // reached treshold
	{
		return true;
	}
	Vector3 force = dist - target; //TODO we only have one effector  so weird huh ?

	//q' = tr(J) * force

	VectorXd qVel = (tree.jacobian.transpose() * force) *stepSize_;

	for( int i = 1; i <= qVel.rows(); ++i ) // starting at 1 %*ù$ù
	{
		tree.GetJoint(i)->AddToTheta(-qVel(i-1));
	}
	
	return false;
}
