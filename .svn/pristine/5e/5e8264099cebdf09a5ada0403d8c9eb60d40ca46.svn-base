#include "kinematic/Tree.h"
#include "kinematic/Sample.h"
#include "kinematic/SampleGenerator.h"

#include "SimpleSampleVisitor.h"

#include "MatrixDefs.h"
#include "kinematic/Pi.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#ifdef WIN32
#include <windows.h>
#endif

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <GL/glui.h>

#include <iostream>

using namespace std;

#define RADIAN(X)	((X)*DegreesToRadians)

using namespace matrices;
using namespace Eigen;

Tree* test; // TO F... REMOVE

SimpleSampleVisitor visitor;
SampleGenerator* generator = SampleGenerator::GetInstance();

Vector3 Target(0,0,0);

//static void ViewOrtho(int x, int y)							// Set Up An Ortho View
//{
//	glMatrixMode(GL_PROJECTION);					// Select Projection
//	glPushMatrix();							// Push The Matrix
//	glLoadIdentity();						// Reset The Matrix
//	glOrtho(0, x , y , 0, -40, 40);				// Select Ortho Mode
//	glMatrixMode(GL_MODELVIEW);					// Select Modelview Matrix
//	glPushMatrix();							// Push The Matrix
//	glLoadIdentity();						// Reset The Matrix
//}
//
//static void ViewPerspective(void)							// Set Up A Perspective View
//{
//	glMatrixMode(GL_PROJECTION);					// Select Projection
//	glPopMatrix();							// Pop The Matrix
//	glMatrixMode(GL_MODELVIEW);					// Select Modelview
//	glPopMatrix();							// Pop The Matrix
//}

void GetOGLPos(int x, int y, Vector3& res)
{
    GLint viewport[4];
    GLdouble modelview[16];
    GLdouble projection[16];
    GLfloat winX, winY, winZ;
    GLdouble posX, posY, posZ;
 
    glGetDoublev(GL_MODELVIEW_MATRIX, modelview);
    glGetDoublev(GL_PROJECTION_MATRIX, projection);
    glGetIntegerv(GL_VIEWPORT, viewport);
 
    winX = (float)x;
    winY = (float)viewport[3] - (float)y;
    glReadPixels(x, int(winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &winZ);
 
    gluUnProject(winX, winY, winZ, modelview, projection, viewport, &posX, &posY, &posZ);
 
	res.x() = posX;
	res.y() = posY;
	res.z() = posZ;
	//return CVector3(posX, posY, posZ);
}

static bool handleDirection(int cmd)
{
	bool found = false;
	double delta = 0.05;
	Vector3* dir = test->directionForce_;
	switch (cmd)
		// force
		{
		case 'o':
			found = true;
			test->directionForce_->z() = test->directionForce_->z() + delta;
			break;
		case 'l':
			test->directionForce_->z() = test->directionForce_->z() - delta;
			found = true;
			break;
		case 'm':
			test->directionForce_->x() = test->directionForce_->x() + delta;
			found = true;
			break;
		case 'k':
			test->directionForce_->x() = test->directionForce_->x() - delta;
			found = true;
			break;
		// velocity
		case 'u':
			found = true;
			test->directionVel_->z() = test->directionVel_->z() + delta;
			break;
		case 'j':
			test->directionVel_->z() = test->directionVel_->z() - delta;
			found = true;
			break;
		case 'h':
			test->directionVel_->x() = test->directionVel_->x() + delta;
			found = true;
			break;
		case 'y':
			test->directionVel_->x() = test->directionVel_->x() - delta;
			found = true;
			break;
		}
		if(found) 
		{
			test->directionForce_->normalize();
			test->directionVel_->normalize();
		}
	return found;
}

static void DrawTarget(const Vector3& pos)
{
	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	float t[3];
	vect3ToArray(t, pos); 
	dsDrawSphere(t, Identity, 0.05);
}

static void DrawArrow(const Vector3& from, const Vector3& dir)
{
	/*Vector3 dest; GetOGLPos(from.x(), from.y(), dest);
	Vector3 destdir = dest + dir;*/
	
	//glDisable(GL_LIGHTING);
	//glColor3f(1.0f, 1.0f, 0.0f);
	//glLineWidth(4.0);
	//glBegin(GL_LINES);
	//glVertex3f(dest.x(), dest.y(), 1); //dest.z());
	//glVertex3f(destdir.x(), destdir.y(), destdir.z());
	//glEnd();
	//glLineWidth(1.0);
	//glEnable(GL_LIGHTING);

	float Identity [12] = { 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f, 0.f, 0.f, 0.f, 1.f, 0.f };
	
	Vector3 destdir = from+dir;
	float fr[3];
	float t[3];
	vect3ToArray(fr, from); 
	vect3ToArray(t, destdir); 
	dsDrawLine  (fr, t);
	dsDrawSphere(t, Identity, 0.02);


	//ViewOrtho(200, 200);
	//glDisable(GL_LIGHTING);
	//glColor3f(1.0f, 1.0f, 0.0f);
	//glLineWidth(2.0);
	//glBegin(GL_LINES);
	//glVertex3f(from.x(), from.y(), from.z());
	//glVertex3f(to.x(), to.y(), to.z());
	//glEnd();
	//glLineWidth(1.0);
	//glEnable(GL_LIGHTING);
	//
	//ViewPerspective();
/*	glDisable(GL_LIGHTING);
	glColor3f(1.0f, 1.0f, 0.0f);
	glLineWidth(2.0);
	glBegin(GL_LINES);
	glVertex3f(from.x(), from.y(), from.z());
	glVertex3f(to.x(), to.y(), to.z());
	glEnd();
	glLineWidth(1.0);
	glEnable(GL_LIGHTING);*/
}

void DrawEllipse(float rx =1.f,float ry=1.f, float rz = 0.5f)
{
	float sina;
	float a, b, x, y, z;

	float pas = 0.01f;
	glColor3f(1.0f, 1.0f, 0.0f);


	glBegin(GL_POINTS);

	for (a=0.0f; a <= Pi; a+=pas)
	{
		z = rz*cosf(a);
		sina = sinf (a);
		for (b=-Pi; b <= Pi; b+=pas)
		{			
			  	  
			x =rx*sina * cosf(b);
		  
			y =ry*sina * sinf(b);
	  
			//normal(x, y, z);
			glVertex3f(x,y,z) ;

		}
	}
	glEnd();
}

static void setTransform (const float pos[3], const float R[12])
{
  GLfloat matrix[16];
  matrix[0]=R[0];
  matrix[1]=R[4];
  matrix[2]=R[8];
  matrix[3]=0;
  matrix[4]=R[1];
  matrix[5]=R[5];
  matrix[6]=R[9];
  matrix[7]=0;
  matrix[8]=R[2];
  matrix[9]=R[6];
  matrix[10]=R[10];
  matrix[11]=0;
  matrix[12]=pos[0];
  matrix[13]=pos[1];
  matrix[14]=pos[2];
  matrix[15]=1;
  glPushMatrix();
  glMultMatrixf (matrix);
}

void DrawEllipse(const Vector3& pos, Tree* tree)
{
	//Getting svd
	//Matrix3d u = tree->svd_.matrixU();
	//VectorXd sing = tree->svd_.singularValues();
	DrawEllipse(sing(0), sing(1), sing(2));
	const Vector3 from(-1, 0, 2);
	/*DrawArrow(from, u.col(0));
	DrawArrow(from, u.col(1));
	DrawArrow(from, u.col(2));*/

	float rx, ry, rz, xf, yf, zf;
	rx = sing(0);
	ry = sing(1);
	rz = sing(2);

	float sina;
	float a, b, x, y, z;

	float pas = 0.01f;
	glColor3f(1.0f, 1.0f, 0.0f);


	glBegin(GL_POINTS);


	//directing vectors values
	float ox, oy, oz, x0,y0,z0,x1,y1,z1,x2,y2,z2;
	x0 = u(0,0); x1 = u(0,1); x2 = u(0,2);
	y0 = u(1,0); y1 = u(1,1); y2 = u(1,2);
	z0 = u(2,0); z1 = u(2,1); z2 = u(2,2);
	ox = pos(0); oy = pos(1); oz = pos(2);

	for (a=0.0f; a <= Pi; a+=pas)
	{
		z = rz*cosf(a);
		sina = sinf (a);
		for (b=-Pi; b <= Pi; b+=pas)
		{			
			  	  
			x =rx*sina * cosf(b);
		  
			y =ry*sina * sinf(b);
	  
			//normal(x, y, z);
			//rotation with correct angles
			xf = ox + x * x0 + y * x1 + z * x2;
			yf = oy + x * y0 + y * y1 + z * y2;
			zf = oz + x * z0 + y * z1 + z * z2;

			//glVertex3f(x,y,z) ;
			glVertex3f(xf,yf,zf) ;

		}
	}
	glEnd();
	
}


void command(int cmd)   /**  key control function; */
{
	Sample * res;
	MatrixX res1(5,1); res1 << 1, 1, 1, 1, 1 ; 
	MatrixX res2(5,1); res2 << -1, -1, -1, -1, -1 ;
	res1 = test->Identitymin * res1;
	res2 = test->Identitymin * res2;
	if (! handleDirection(cmd))
	{
		Joint* joint(0);
		int sens = 1;
		switch (cmd)
		{
		case 'i' :
		test->GetJoint(1)->AddToTheta(res1(0)*0.01);
		test->GetJoint(2)->AddToTheta(res1(1)*0.01);
		test->GetJoint(3)->AddToTheta(res1(2)*0.01);
		test->GetJoint(4)->AddToTheta(res1(3)*0.01);
		test->GetJoint(5)->AddToTheta(res1(4)*0.01);
		break;
		case 'p' :
			test->GetJoint(1)->AddToTheta(res2(0)*0.01);
			test->GetJoint(2)->AddToTheta(res2(1)*0.01);
			test->GetJoint(3)->AddToTheta(res2(2)*0.01);
			test->GetJoint(4)->AddToTheta(res2(3)*0.01);
			test->GetJoint(5)->AddToTheta(res2(4)*0.01);
		break;
		case 'w' :
			test->ToRest();
			break;
		case 'x':
			{	//force
				visitor.Configure(1.f, 0.f);
				res = visitor.Run(*generator, *(test->directionForce_), *(test->directionVel_), Target);
				if(res)
				{
					res->LoadIntoTree(*test);
				}
				//generator->Accept(visitor);
				break;
			}
		case 'c':
			test->OptimizeCurrentConfiguration(); 
			break;
		case 'v':
			//vitesse
			{
				visitor.Configure(0.f, 1.f);
				res = visitor.Run(*generator, *(test->directionForce_), *(test->directionVel_), Target);
				if(res)
				{
					res->LoadIntoTree(*test);
				}
				//generator->Accept(visitor);
				break;
			}
			case 'n':
			//controle vitesse, grande force
			{
				visitor.Configure(1.f, -1.f);
				res = visitor.Run(*generator, *(test->directionForce_), *(test->directionVel_), Target);
				if(res)
				{
					res->LoadIntoTree(*test);
				}
				//generator->Accept(visitor);
				break;
			}
		case 'b':
			test->ApproximateVelocityManipulabilityBruteForce(); 
			break;
		case 'a':
			joint = test->GetJoint(1); // increases THETA[1] when a key is pressed
			break;
		case 'z':
			joint = test->GetJoint(2);
			break;
		case 'e':
			joint = test->GetJoint(3);
			break;
		case 'r':
			joint = test->GetJoint(4);
			break;
		case 't':
			joint = test->GetJoint(5);
			break;
		case 'q':
			sens = -1;
			joint = test->GetJoint(1); // increases THETA[1] when a key is pressed
			break;
		case 's':
			sens = -1;
			joint = test->GetJoint(2);
			break;
			sens = -1;
		case 'd':
			sens = -1;
			joint = test->GetJoint(3);
			break;
		case 'f':
			sens = -1;
			joint = test->GetJoint(4);
			break;
		case 'g':
			sens = -1;
			joint = test->GetJoint(5);
			break;
		}
		if (joint)
		{
			joint->AddToTheta(0.05 * sens);
		}
	}
}

void BuildTree(Joint *node[], Tree &tree)
{
	const Vector3 unitx(1, 0, 0);
	const Vector3 unity(0, 1, 0);
	const Vector3 unitz(0, 0, 1);
	const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
	const Vector3 zero(0,0,0);

	/*VERTICAL ARM*/
	
	node[0] = new Joint(Vector3(0.0, 0.0, 1.7), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0), Y);
	tree.InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, 0.0, 1.7), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0), X);
	tree.InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, 0.0, 1.7), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0), Z);
	tree.InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 0.0, 0.9), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0), Y);
	tree.InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 0.0, 0.9), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 0.0, 0.0), zero,EFFECTOR);
	tree.InsertChild(node[4], node[5]);

	/*HORIZONTAL ARM*/
	/*
	node[0] = new Joint(Vector3(0.0, -0.5, 0.0), unity,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Y);
	tree.InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, -0.5, 0.0), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, -0.5, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), Z);
	tree.InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 0.4, 0.0), unitz,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.));
	tree.InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 0.4, 0.0), unitx,JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(30.), X);
	tree.InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 1.2, 0.0), zero,EFFECTOR);
	tree.InsertChild(node[4], node[5]);*/
	
	
	test = &tree; // to remove
}

/**
Drawstuff stuff : 
*/

static void DrawJoint(Joint* joint, Matrix4& currentTransform)
{
	float length = 1.6f;
	//joint->AddToTheta(Pi / 240.);
	
if (joint->IsEffector())
{
	//joint->AddToTheta(Pi / 2400.);
}

	//joint->AddToTheta(Pi / 24000.);

	//draw line between positions
	float from[3];
	vect4ToArray(from, currentTransform.col(3));

	Matrix4 jointTransform = Translate(joint->GetR()); // translation of current joint
	switch(joint->GetRotation())
	{
		case X:
			jointTransform = jointTransform + Rotx4(joint->GetTheta());
			break;
		case Y:
			jointTransform = jointTransform + Roty4(joint->GetTheta());
			break;
		case Z:
			jointTransform = jointTransform + Rotz4(joint->GetTheta());
			break;
	}
	//currentTransform = currentTransform * (Rotz4(joint->GetTheta()) + Translate(joint->GetR()));
	currentTransform = currentTransform * jointTransform;
//std::cout << currentTransform << std::endl;

	float R[12];
	matrixToArray(R, currentTransform);
	//cout << currentTransform << endl;
    dsSetColor(1.0,0.0,0.0);
	float ps[3];
	vect4ToArray(ps, currentTransform.col(3));
	//= {currentTransform(0,3), currentTransform(1,3), currentTransform(2,3)};
	//double ps[3] = {0,0,0};
	if(joint->pChild_)
	{
		dsDrawSphere (ps, R, 0.05);
	}
	else
	{
		float sides[3] = {0.05, 0.05, 0.05};
		dsDrawBox(ps, R, sides);
	}

	//draw line between positions
	if(joint->pRealparent_)
		dsDrawLine(from, ps);

 //   dsSetColor(0.0,1.0,0.0);
	//Vector3 pos = joint->GetS();
	//for(int j =0; j< 3; ++j)
	//{
	//	ps[ j ] = float(pos(j));
	//}
	//ps[ 2 ] = ps[ 2 ] + 0.5f;
	//dsDrawSphere (ps, R, 0.05);

	////draw line between positions
	//from[ 2 ] = from[ 2 ] + 0.5f;
	//if(joint->pRealparent_)
	//	dsDrawLine(from, ps);
}

static void DrawTree(Tree* tree)
{
	tree->Compute();
	//joint->AddToTheta(Pi / 240.);
	Matrix4 m =  Matrix4::Identity();
	//cout << m << endl;
	Joint* joint = tree->GetRoot();
	//joint->AddToTheta(Pi / 2400.);
	while (joint) {
		DrawJoint(joint, m);
		joint = (joint->IsEffector() ? 0 : tree->GetSuccessor(joint));
		/*if (joint)
		{
			joint->AddToTheta(Pi / 240.);
		}*/
	}
	
	tree->ComputeJacobian();
	
	Vector3 haut (0.0, 0.0, -1.0);
	Vector3 droite (1.0, 0.0, 0.0);
	std::cout << " FORCE MANIPULABILITY "	 << tree->ComputeForceManipulability() << std::endl << std::endl ;
	std::cout << " VELOCITY MANIPULABILITY " << tree->ComputeVelocityManipulability() << std::endl << std::endl << std::endl << std::endl;
}


static void simLoop (int pause)
{
	const Vector3 arrowFrom(0.5, 0, 0.5);
	DrawTree(test);
    dsSetColor(1.0, 1.0, 0.0);
	DrawArrow(arrowFrom, *(test->directionForce_));
    dsSetColor(1.0, 1.0, 1.0);
	DrawArrow(arrowFrom, *(test->directionVel_));
	DrawTarget(Target);
	DrawEllipse(test->GetJoint(5)->GetS() + test->GetJoint(5)->GetR(), test);
}

void start()
{
    static float xyz[3] = {0.0,-3.0,1.0};
    static float hpr[3] = {90.0,0.0,0.0};
    dsSetViewpoint (xyz,hpr);
}



int main(int argc, char *argv[])
{
	Tree treeY;
	//Jacobian *jacobY;
	Joint* joints[5];
	BuildTree(joints,treeY);
	treeY.Init();
	treeY.Compute();
	visitor.Configure(0.f, 1.f);
				
	//SAMPLE TESTING
	generator->GenerateSamples(*test, 10);

	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
	fn.command = &command;
    fn.stop    = 0;
    fn.path_to_textures = "./textures";
    dsSimulationLoop (argc,argv,352,288,&fn);

    return 0;
}
