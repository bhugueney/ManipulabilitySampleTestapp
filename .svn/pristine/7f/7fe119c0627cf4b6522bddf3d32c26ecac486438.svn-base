
#include "TreeFactory.h"
#include "Tree.h"
#include "Joint.h"
#include "Pi.h"
#include "Com.h"

#include <vector>

using namespace matrices;

namespace factories
{
const Vector3 unitx(1, 0, 0);
const Vector3 unity(0, 1, 0);
const Vector3 unitz(0, 0, 1);
const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
const Vector3 zero(0,0,0);

struct TreeFactoryPimpl{
	TreeFactoryPimpl()
	{
		// NOTHING
	}
	
	~TreeFactoryPimpl()
	{
		// NOTHING
	}
	
	Tree* CreateHumanTorso(const Vector3& root, const Tree::TREE_ID id)
	{
		Tree* torso = new Tree(id, 2);
		Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(0), RADIAN(0), RADIAN(0), Y);
		torso->InsertRoot(j0);

		Joint* j1 = new Joint(Vector3(root(0), root(1), root(2) + 1.), unity, JOINT, comFact_.CreateCom(Trunk), RADIAN(0)  , RADIAN(0)  , RADIAN(0), Y);
		torso->InsertChild(j0, j1);

		Joint* j2 = new Joint(Vector3(root(0), root(1), root(2) + 1.3), unitx, EFFECTOR, comFact_.CreateCom(Head), RADIAN(0), RADIAN(0) , RADIAN(0),  X);
		torso->InsertChild(j1, j2);

		return torso;
	}

	Tree* CreateQuadrupedTorso(const Vector3& root, const Tree::TREE_ID id) // TODO
	{
		Tree* torso = new Tree(id, 1);
		Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(0), RADIAN(0), RADIAN(0), Y);
		torso->InsertRoot(j0);

		Joint* j1 = new Joint(Vector3(root(0) + 2., root(1), root(2)), unity, JOINT, comFact_.CreateCom(Trunk), RADIAN(0)  , RADIAN(0)  , RADIAN(0), Y);
		torso->InsertChild(j0, j1);

		Joint* j2 = new Joint(Vector3(root(0) + 2.3, root(1), root(2)), unitx, EFFECTOR, comFact_.CreateCom(Head), RADIAN(0), RADIAN(0) , RADIAN(0),  X);
		torso->InsertChild(j1, j2);

		return torso;
	}

	Tree* CreateArm(const Vector3& root, const Tree::TREE_ID id) const
	{
		Tree* arm = new Tree(id, 0);
		Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(0),   Y);
		arm->InsertRoot(j0);

		Joint* j1 = new Joint(root, unitx, JOINT, comFact_.CreateCom(None), RADIAN(-135) , RADIAN(135) , RADIAN(0),   X);
		arm->InsertChild(j0, j1);

		Joint* j2 = new Joint(root, unitz, JOINT, comFact_.CreateCom(None), RADIAN(-120)  , RADIAN(45)  , RADIAN(0),   Z);
		arm->InsertChild(j1, j2);

		Joint* j3 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unity, JOINT, comFact_.CreateCom(UpperAm), RADIAN(-90)  , RADIAN(45)  , RADIAN(-30), Y);
		arm->InsertChild(j2, j3);

		Joint* j4 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unitx, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(0.),  X);
		arm->InsertChild(j3, j4);
	 
		Joint* j5 = new Joint(Vector3(root(0), root(1), root(2) - 1.7), zero, EFFECTOR, comFact_.CreateCom(ForeArm));
		arm->InsertChild(j4, j5);
		return arm;
	}

	Tree* CreateLeg(const Vector3& root, const Tree::TREE_ID id) const
	{
		Tree* leg = new Tree(id, 1);
		Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(0),    Y);
		leg->InsertRoot(j0);

		Joint* j1 = new Joint(root, unitx, JOINT, comFact_.CreateCom(None), RADIAN(-30) , RADIAN(30) , RADIAN(0),    X);
		leg->InsertChild(j0, j1);

		Joint* j2 = new Joint(root, unitz, JOINT, comFact_.CreateCom(None), RADIAN(-15)  , RADIAN(15)  , RADIAN(0),    Z);
		leg->InsertChild(j1, j2);

		Joint* j3 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unity, JOINT, comFact_.CreateCom(Thigh), RADIAN(0)  , RADIAN(120)  , RADIAN(30), Y);
		leg->InsertChild(j2, j3);

		Joint* j4 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unitx, JOINT, comFact_.CreateCom(None), RADIAN(-10.), RADIAN(10.) , RADIAN(0.),  X);
		leg->InsertChild(j3, j4);

		Joint* j5 = new Joint(Vector3(root(0), root(1), root(2) - 1.7), zero, EFFECTOR, comFact_.CreateCom(Calf));
		leg->InsertChild(j4, j5);
		return leg;
	}

	Tree* CreateQuadrupedLeg(const Vector3& root, const Tree::TREE_ID id) const
	{
		Tree* leg = new Tree(id, 0);
		Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(0),    Y);
		//Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(180),    Y);
		leg->InsertRoot(j0);

		Joint* j1 = new Joint(root, unitx, JOINT, comFact_.CreateCom(None), RADIAN(-30) , RADIAN(30) , RADIAN(0),    X);
		leg->InsertChild(j0, j1);

		Joint* j2 = new Joint(root, unitz, JOINT, comFact_.CreateCom(None), RADIAN(-15)  , RADIAN(15)  , RADIAN(0),    Z);
		leg->InsertChild(j1, j2);

		Joint* j3 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unity, JOINT, comFact_.CreateCom(Thigh), RADIAN(0)  , RADIAN(120)  , RADIAN(30), Y);
		leg->InsertChild(j2, j3);

		Joint* j4 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unitx, JOINT, comFact_.CreateCom(None), RADIAN(-10.), RADIAN(10.) , RADIAN(0.),  X);
		leg->InsertChild(j3, j4);

		Joint* j5 = new Joint(Vector3(root(0), root(1), root(2) - 1.7), zero, EFFECTOR, comFact_.CreateCom(Calf));
		leg->InsertChild(j4, j5);
		return leg;
	}

	Tree* CreateQuadrupedLegLeft(const Vector3& root, const Tree::TREE_ID id) const
	{
		Tree* leg = new Tree(id, 0);
		Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(0),    Y);
		//Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(180),    Y);
		leg->InsertRoot(j0);

		Joint* j1 = new Joint(root, unitx, JOINT, comFact_.CreateCom(None), RADIAN(0) , RADIAN(30) , RADIAN(0),    X);
		leg->InsertChild(j0, j1);

		Joint* j2 = new Joint(root, unitz, JOINT, comFact_.CreateCom(None), RADIAN(-15)  , RADIAN(15)  , RADIAN(0),    Z);
		leg->InsertChild(j1, j2);

		Joint* j3 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unity, JOINT, comFact_.CreateCom(Thigh), RADIAN(0)  , RADIAN(120)  , RADIAN(30), Y);
		leg->InsertChild(j2, j3);

		Joint* j4 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unitx, JOINT, comFact_.CreateCom(None), RADIAN(-10.), RADIAN(10.) , RADIAN(0.),  X);
		leg->InsertChild(j3, j4);

		Joint* j5 = new Joint(Vector3(root(0), root(1), root(2) - 1.7), zero, EFFECTOR, comFact_.CreateCom(Calf));
		leg->InsertChild(j4, j5);
		return leg;
	}

	Tree* CreateQuadrupedLegRight(const Vector3& root, const Tree::TREE_ID id) const
	{
		Tree* leg = new Tree(id, 0);
		Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(0),    Y);
		//Joint* j0 = new Joint(root, unity, JOINT, comFact_.CreateCom(None), RADIAN(-180.), RADIAN(180.), RADIAN(180),    Y);
		leg->InsertRoot(j0);

		Joint* j1 = new Joint(root, unitx, JOINT, comFact_.CreateCom(None), RADIAN(-30) , RADIAN(0) , RADIAN(0),    X);
		leg->InsertChild(j0, j1);

		Joint* j2 = new Joint(root, unitz, JOINT, comFact_.CreateCom(None), RADIAN(-15)  , RADIAN(15)  , RADIAN(0),    Z);
		leg->InsertChild(j1, j2);

		Joint* j3 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unity, JOINT, comFact_.CreateCom(Thigh), RADIAN(0)  , RADIAN(120)  , RADIAN(30), Y);
		leg->InsertChild(j2, j3);

		Joint* j4 = new Joint(Vector3(root(0), root(1), root(2) - 0.8), unitx, JOINT, comFact_.CreateCom(None), RADIAN(-10.), RADIAN(10.) , RADIAN(0.),  X);
		leg->InsertChild(j3, j4);

		Joint* j5 = new Joint(Vector3(root(0), root(1), root(2) - 1.7), zero, EFFECTOR, comFact_.CreateCom(Calf));
		leg->InsertChild(j4, j5);
		return leg;
	}

	ComFactory comFact_;
};
}

using namespace factories;

TreeFactory::TreeFactory()
	: pImpl_(new TreeFactoryPimpl())
{
	// NOTHING
}


TreeFactory::~TreeFactory()
{
	// NOTHING
}

Tree* TreeFactory::CreateTree(const eMembers member, const Vector3& rootPosition, const Tree::TREE_ID id) const
{
	switch (member)
		{
			case Arm:
				{
					return pImpl_->CreateArm(rootPosition, id);
				}
			case Leg:
				{
					return pImpl_->CreateLeg(rootPosition, id);
				}
			case HumanTorso:
				{
					return pImpl_->CreateHumanTorso(rootPosition, id);
				}
			case QuadrupedTorso:
				{
					return pImpl_->CreateQuadrupedTorso(rootPosition, id);
				}
			case QuadrupedLeg:
				{
					return pImpl_->CreateQuadrupedLeg(rootPosition, id);
				}
			case QuadrupedLegLeft:
				{
					return pImpl_->CreateQuadrupedLegLeft(rootPosition, id);
				}
			case QuadrupedLegRight:
				{
					return pImpl_->CreateQuadrupedLegRight(rootPosition, id);
				}
			default:
				throw(std::exception("unknown tree type"));
		}
}


