#include "kinematic/Joint.h"
#include "kinematic/Tree.h"
#include "kinematic/Robot.h"

#include "kinematic/MatrixDefs.h"
#include "kinematic/Pi.h"

#include "DrawRobot.h"

#include <drawstuff/drawstuff.h> // The drawing library for ODE;

#ifdef WIN32
#include <windows.h>
#endif

#include <iostream>
#include <vector>

#define RADIAN(X)	((X)*DegreesToRadians)

using namespace matrices;
using namespace Eigen;
using namespace std;

// main object
Robot* pRobot;
DrawRobot* pDrawRobot;

void command(int cmd)   /**  key control function; */
{
	//NOTHING
}

void BuildRobot(Robot& robot)
{
	//principal axes constants
	const Vector3 unitx(1, 0, 0);
	const Vector3 unity(0, 1, 0);
	const Vector3 unitz(0, 0, 1);
	const Vector3 unit1(sqrt(14.0)/8.0, 1.0/8.0, 7.0/8.0);
	const Vector3 zero(0,0,0);

	/*RIGHT ARM*/
	Joint* node[6];
	Tree* rightArm = new Tree();
	node[0] = new Joint(Vector3(0.0, 0.0, 1.7), unity, JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0),   Y);
	rightArm->InsertRoot(node[0]);

	node[1] = new Joint(Vector3(0.0, 0.0, 1.7), unitx, JOINT, RADIAN(-135) , RADIAN(135) , RADIAN(0),   X);
	rightArm->InsertChild(node[0], node[1]);

	node[2] = new Joint(Vector3(0.0, 0.0, 1.7), unitz, JOINT, RADIAN(-45)  , RADIAN(45)  , RADIAN(0),   Z);
	rightArm->InsertChild(node[1], node[2]);

	node[3] = new Joint(Vector3(0.0, 0.0, 0.9), unity, JOINT, RADIAN(-90)  , RADIAN(45)  , RADIAN(-30), Y);
	rightArm->InsertChild(node[2], node[3]);

	node[4] = new Joint(Vector3(0.0, 0.0, 0.9), unitx, JOINT, RADIAN(-180.), RADIAN(180.), RADIAN(0.),  X);
	rightArm->InsertChild(node[3], node[4]);

	node[5] = new Joint(Vector3(0.0, 0.0, 0.0), zero, EFFECTOR);
	rightArm->InsertChild(node[4], node[5]);

	robot.AddTree(rightArm);
}

/**
Drawstuff stuff :
*/
static void simLoop (int pause)
{
	pDrawRobot->Draw();
}

void start()
{
    static float xyz[3] = {0.0,-3.0,1.0};
    static float hpr[3] = {90.0,0.0,0.0};
    dsSetViewpoint (xyz,hpr);
}

int main(int argc, char *argv[])
{
	//Jacobian *jacobY;
	//init robot
	Matrix4 robotBasis( Eigen::MatrixXd::Identity(4,4) );
	Robot robot(robotBasis);
	BuildRobot(robot);
	pRobot = &robot;

	//init DrawRobot
	DrawRobot dRobot(robot);
	pDrawRobot = &dRobot;
				
	/*
	drawstuff stuff*/
	dsFunctions fn;
    fn.version = DS_VERSION;
    fn.start   = &start;
    fn.step    = &simLoop;
	fn.command = &command;
    fn.stop    = 0;
    fn.path_to_textures = "./textures";
    dsSimulationLoop (argc,argv,800,600,&fn);

    return 0;
}
